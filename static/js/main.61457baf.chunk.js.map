{"version":3,"sources":["modules/javascript/greek.js","modules/javascript/latin.js","components/Translation.js","components/Mult.js","App.js","index.js"],"names":["convert","require","flatten","getGreekMorph","lemma","a","fetch","mode","greekData","json","dataOut","body","RDF","Annotation","Body","returnArr","Array","isArray","subObj","i","length","type","undefined","rest","entry","infl","pofs","$","inflections","headWord","dict","hdwd","fixedHead","replace","inflect","getGreekInflections","getWikiGreek","shortDict","getPerseusGreek","longDict","headword","dialect","shortDef","longDef","inflection","inflectArr","combinedArr","mood","tense","voice","dial","person","pers","number","num","gender","gend","grekCase","case","nCase","declension","decl","dictEntry","entryOut","other","defArr","definitions","def","definition","fixedDef","betterDef","beta","greekToBetaCode","dataAsJson","data","text","textData","indexOf","data1","textData1","JSON","parse","xml2json","compact","spaces","lower","div0","sense","defArray","flatter","regex1","regex2","regex3","regex4","allowedArr","Object","entries","filter","key","value","test","allowedObj","fromEntries","push","joined","subArr","endArr","map","endStr","join","getLatinMorph","latinData","console","log","retArr","getLatininflectArr","getWikiLatin","getPerseusLatin","check","stringify","latCase","latTense","latMood","latVoice","conj","latinDef","defOut","defOut_Latin","la","defHTML","document","getElementById","innerHTML","titles","querySelectorAll","sumDef","textContent","asArray","Translation","props","className","provided","head","short","item","keys","val","charAt","toUpperCase","slice","format","long","Mult","input","lang","el","index","App","useState","greek","setGreek","latin","setLatin","language","setLanguage","greekArr","setGreekArr","latinArr","setLatinArr","displayArr","setDisplayArr","morphList","setMorphList","visible","setVisible","active","setActive","activeIndex","setActiveIndex","loaded","setLoaded","useEffect","arr","word","grekWord","getGreekPhrase","latWord","getLatinPhrase","handleChange","e","target","handleLang","cleaned","split","preventDefault","id","onSubmit","onChange","name","placeholder","Button","variant","color","classes","label","onMouseDown","setClicked","onMouseEnter","displayMorph","onMouseLeave","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.61457baf.chunk.js","sourcesContent":["import {  greekToBetaCode  } from 'beta-code-js'; \nconst convert = require('xml-js');\nconst flatten = require('flat');\n\n\nconst getGreekMorph = async (lemma) => { //returns a full array of relevant information relating to the morphology, including the headword, part of speech, inflection possibilities, Wiktionary Def, and LSJ Def\n    \n    // fetches the given greek string from the morphology service\n    const greekData = await fetch(`https://services.perseids.org/bsp/morphologyservice/analysis/word?lang=grc&engine=morpheusgrc&word=${lemma}`, {mode: 'cors'});\n    const dataOut = await greekData.json();\n    const body = dataOut.RDF.Annotation.Body;\n    //console.log(dataOut);\n    if(body === undefined){\n        //console.log('undefined');\n    }\n\n    //console.log(dataOut);\n\n    let type;\n    let returnArr = [];\n    if(Array.isArray(body)){ // if multiple possible definitions, returns morphology array for each\n        let subObj = {};\n        for(let i = 0; i < body.length; i++){\n            if(dataOut.RDF.Annotation.Body[i].rest.entry.infl[0] !== undefined){\n                type = (dataOut.RDF.Annotation.Body[i].rest.entry.infl[0].pofs.$);\n            } else {\n                type = dataOut.RDF.Annotation.Body[i].rest.entry.infl.pofs.$;\n            }\n            const inflections = dataOut.RDF.Annotation.Body[i].rest.entry.infl;\n            let headWord = dataOut.RDF.Annotation.Body[i].rest.entry.dict.hdwd.$;\n            let fixedHead = headWord.replace(/[1-9]/g, '');\n            const inflect = getGreekInflections(inflections, type);\n            const shortDict = await getWikiGreek(fixedHead);\n            const longDict = await getPerseusGreek(fixedHead);\n\n            //console.log(shortDict);\n\n            if(inflect === undefined){ // iff word is not inflected, returns array without inflections (numerals, particles, etc.)\n                subObj = {\n                            headword: fixedHead, \n                            type: type, \n                            inflections: [\n                                {\n                                    dialect: \"n/a\",\n                                    inflections: \"uninflected\"\n                                }\n                            ], \n                            shortDef: shortDict,\n                            longDef: longDict\n                        };\n            } else {\n                subObj = {\n                    headword: fixedHead, \n                    type: type, \n                    inflections: inflect,\n                    shortDef: shortDict,\n                    longDef: longDict\n                };\n            }\n            returnArr[i] = subObj;\n        }\n        \n        return returnArr; //full array of word possibilities based on each possible root headword from input word\n\n    } else { //if there is only one root headword possible\n        \n        if(dataOut.RDF.Annotation.Body.rest.entry.infl[0] !== undefined){\n            type = (dataOut.RDF.Annotation.Body.rest.entry.infl[0].pofs.$);\n        } else {\n            type = dataOut.RDF.Annotation.Body.rest.entry.infl.pofs.$;\n        }\n    \n        const inflections = dataOut.RDF.Annotation.Body.rest.entry.infl;\n        let headWord = dataOut.RDF.Annotation.Body.rest.entry.dict.hdwd.$;\n        let fixedHead = headWord.replace(/[1-9]/g, '');\n        const inflect = getGreekInflections(inflections, type);\n        const shortDict = await getWikiGreek(fixedHead);\n        const longDict = await getPerseusGreek(fixedHead);\n\n        if(inflect === undefined){ // as before, if word is not inflected, returns array without inflections (numerals, particles, etc.)\n            return [{\n                    headword: fixedHead, \n                    type: type, \n                    inflections: [\n                        {\n                            dialect: 'n/a',\n                            inflection: 'uninflected'\n                        }\n                    ], \n                    shortDef: shortDict,\n                    longDef: longDict\n                }];\n        } else {\n            return [{   \n                    headword: fixedHead,\n                    type: type,\n                    inflections: inflect,\n                    shortDef: shortDict,\n                    longDef: longDict\n                }];\n        }   \n    }\n};\n\nconst getGreekInflections = (inflectArr, type) => { // returns an array in which each element is an object of the dialect type and inflection pattern\n\n    if (type === 'verb') { //all other if statements contain similar code that will change what is returned in the object, depending on word type.\n        if(Array.isArray(inflectArr)){ // if multiple inflection possibilities, returns array of all possible inflections. \n            let combinedArr = [];\n                for(let i = 0; i < inflectArr.length; i++){\n                    if (inflectArr[i].mood.$ === 'infinitive') {\n                        let tense = inflectArr[i].tense.$;\n                        let voice = inflectArr[i].voice.$;\n                        let mood = inflectArr[i].mood.$;\n                        if(inflectArr[i].dial){\n                            let dialect = inflectArr[i].dial.$;\n                            combinedArr[i] = {\n                                dialect: dialect,\n                                inflection: `${tense} ${voice} ${mood}`\n                            };\n                        }else {\n                            combinedArr[i] = {\n                                dialect: 'Attic',\n                                inflection: `${tense} ${voice} ${mood}`\n                            }\n                        }\n                    } else {\n                        let person = inflectArr[i].pers.$;\n                        let number = inflectArr[i].num.$;\n                        let tense = inflectArr[i].tense.$;\n                        let voice = inflectArr[i].voice.$;\n                        let mood = inflectArr[i].mood.$;\n                        if(inflectArr[i].dial){\n                            let dialect = inflectArr[i].dial.$;\n                            combinedArr[i] = {\n                                dialect: dialect,\n                                inflection: `${person} person ${number} ${tense} ${voice} ${mood}`\n                            };\n                        }else {\n                            combinedArr[i] = {\n                                dialect: 'Attic',\n                                inflection: `${person} person ${number} ${tense} ${voice} ${mood}`\n                            }\n                        }\n                    }\n                }\n            return combinedArr;\n        } else {\n            if (inflectArr.mood.$ === 'infinitive') {\n                let tense = inflectArr.tense.$;\n                let voice = inflectArr.voice.$;\n                let mood = inflectArr.mood.$;\n                if(inflectArr.dial){\n                    let dialect = inflectArr.dial.$;\n                    return [{\n                        dialect: dialect,\n                        inflection: `${tense} ${voice} ${mood}`\n                    }];\n                }else {\n                    return [{\n                        dialect: 'Attic',\n                        inflection: `${tense} ${voice} ${mood}`\n                    }];\n                }\n            } else {\n                let person = inflectArr.pers.$;\n                let number = inflectArr.num.$;\n                let tense = inflectArr.tense.$;\n                let voice = inflectArr.voice.$;\n                let mood = inflectArr.mood.$;\n                if(inflectArr.dial){\n                    let dialect = inflectArr.dial.$;\n                    return [{\n                        dialect: dialect,\n                        inflection: `${person} person ${number} ${tense} ${voice} ${mood}`\n                    }];\n                }else {\n                    return [{\n                        dialect: 'Attic',\n                        inflection: `${person} person ${number} ${tense} ${voice} ${mood}`\n                    }];\n                }\n            }\n            \n        }\n    } else if (type === 'verb participle') {\n        if(Array.isArray(inflectArr)){\n            let combinedArr = [];\n                for(let i = 0; i < inflectArr.length; i++){\n                    let gender = inflectArr[i].gend.$;\n                    let grekCase = inflectArr[i].case.$;\n                    let number = inflectArr[i].num.$;\n                    let tense = inflectArr[i].tense.$;\n                    let voice = inflectArr[i].voice.$;\n                    let mood = inflectArr[i].mood.$;\n                    if(inflectArr[i].dial){\n                        let dialect = inflectArr[i].dial.$;\n                        combinedArr[i] = {\n                            dialect: dialect, \n                            inflection: `${gender} ${grekCase} ${number} ${tense} ${voice} ${mood}`\n                        };\n                    } else {\n                        combinedArr[i] = {\n                            dialect: 'Attic',\n                            inflection: `${gender} ${grekCase} ${number} ${tense} ${voice} ${mood}`\n                        };\n                    }\n                }\n            return combinedArr;\n        } else {\n            let gender = inflectArr.gend.$;\n            let grekCase = inflectArr.case.$;\n            let number = inflectArr.num.$;\n            let tense = inflectArr.tense.$;\n            let voice = inflectArr.voice.$;\n            let mood = inflectArr.mood.$;\n            if(inflectArr.dial){\n                let dialect = inflectArr.dial.$;\n                return [{\n                    dialect: dialect, \n                    inflection: `${gender} ${grekCase} ${number} ${tense} ${voice} ${mood}`\n                }];\n            } else {\n                return [{\n                    dialect: 'Attic',\n                    inflection: `${gender} ${grekCase} ${number} ${tense} ${voice} ${mood}`\n                }];\n            }\n        }\n    } else if (type === 'noun') {\n        if(Array.isArray(inflectArr)){\n            let combinedArr = [];\n                for(let i = 0; i < inflectArr.length; i++){\n                    \n                    let gender = inflectArr[i].gend.$;\n                    let nCase = inflectArr[i].case.$;\n                    let number = inflectArr[i].num.$;\n                    let declension = inflectArr[i].decl.$;\n                    if(inflectArr[i].dial){\n                        let dialect = inflectArr[i].dial.$;\n                        combinedArr[i] = {\n                            dialect: dialect, \n                            declension: declension,\n                            inflection: `${gender} ${nCase} ${number}`\n                        };\n                    } else {\n                        combinedArr[i] = {\n                            dialect: 'Attic', \n                            declension: declension,\n                            inflection: `${gender} ${nCase} ${number}`\n                        };\n                    }\n                }\n            return combinedArr;\n        }\n        let gender = inflectArr.gend.$;\n        let nCase = inflectArr.case.$;\n        let number = inflectArr.num.$;\n        let declension = inflectArr.decl.$;\n        if(inflectArr.dial){\n            let dialect = inflectArr.dial.$;\n            return [{\n                dialect: dialect, \n                declension: declension,\n                inflection: `${gender} ${nCase} ${number}`\n            }];\n        } else {\n            return [{\n                dialect: 'Attic', \n                declension: declension,\n                inflection: `${gender} ${nCase} ${number}`\n            }];\n        }\n    } else if (type === 'adjective') {\n        if(Array.isArray(inflectArr)){\n            let combinedArr = [];\n                for(let i = 0; i < inflectArr.length; i++){\n                    \n                    let gender = inflectArr[i].gend.$;\n                    let nCase = inflectArr[i].case.$;\n                    let number = inflectArr[i].num.$;\n                    let declension = inflectArr[i].decl.$;\n                    if(inflectArr[i].dial){\n                        let dialect = inflectArr[i].dial.$;\n                        combinedArr[i] = {\n                            dialect: dialect, \n                            declension: declension,\n                            inflection: `${gender} ${nCase} ${number}`\n                        };\n                    } else {\n                        combinedArr[i] = {\n                            dialect: 'Attic',\n                            declension: declension,\n                            inflection: `${gender} ${nCase} ${number}`\n                        };\n                    }\n                }\n            return combinedArr;\n        }\n        let gender = inflectArr.gend.$;\n        let nCase = inflectArr.case.$;\n        let number = inflectArr.num.$;\n        let declension = inflectArr.decl.$;\n        if(inflectArr.dial){\n            let dialect = inflectArr.dial.$;\n            return [{\n                dialect: dialect, \n                declension: declension,\n                inflection: `${gender} ${nCase} ${number}`\n            }]; \n        } else {\n            return [{\n                dialect: 'Attic',\n                declension: declension,\n                inflection: `${gender} ${nCase} ${number}`\n            }];\n        }\n    } else if (type === 'pronoun') {\n        if(Array.isArray(inflectArr)){\n            let combinedArr = [];\n                for(let i = 0; i < inflectArr.length; i++){\n                    if(inflectArr[i].pers !== undefined) {\n                        let person = inflectArr[i].pers.$;\n                        let gender = inflectArr[i].gend.$;\n                        let nCase = inflectArr[i].case.$;\n                        let number = inflectArr[i].num.$;\n                        \n                        combinedArr[i] = {\n                            inflection: `${person} person ${gender} ${nCase} ${number}`\n                        };\n                    } else {\n                        let gender = inflectArr[i].gend.$;\n                        let nCase = inflectArr[i].case.$;\n                        let number = inflectArr[i].num.$;\n\n                        combinedArr[i] = {\n                            inflection: `${gender} ${nCase} ${number}`\n                        };\n                    }\n                    \n                }\n            return combinedArr;\n        } else {\n            let person = inflectArr.pers.$;\n            let gender = inflectArr.gend.$;\n            let nCase = inflectArr.case.$;\n            let number = inflectArr.num.$;\n            return [{\n                inflection: `${person} person ${gender} ${nCase} ${number}`\n            }];\n        }\n        \n    } else if (type === 'article') {\n        if(Array.isArray(inflectArr)){\n            let combinedArr = [];\n                for(let i = 0; i < inflectArr.length; i++){\n                    \n                    let gender = inflectArr[i].gend.$;\n                    let nCase = inflectArr[i].case.$;\n                    let number = inflectArr[i].num.$;\n                    if(inflectArr[i].dial){\n                        let dialect = inflectArr[i].dial.$;\n                        combinedArr[i] = {\n                            dialect: dialect, \n                            inflection: `${gender} ${nCase} ${number}`\n                        };\n                    } else {\n                        combinedArr[i] = {\n                            dialect: 'Attic', \n                            inflection: `${gender} ${nCase} ${number}`\n                        };\n                    }\n                }\n            return combinedArr;\n        }\n        let gender = inflectArr.gend.$;\n        let nCase = inflectArr.case.$;\n        let number = inflectArr.num.$;\n        if(inflectArr.dial){\n            let dialect = inflectArr.dial.$;\n            return [{\n                dialect: dialect, \n                inflection: `${gender} ${nCase} ${number}`\n            }];\n        } else {\n            return [{\n                dialect: 'Attic', \n                inflection: `${gender} ${nCase} ${number}`\n            }];\n        }\n    } \n\n    //Fix Relative Pronouns, numerals, etc...\n};\n\nconst getWikiGreek = async (lemma) => { // fetches the wiktionary definition for the input word\n    const dictEntry = await fetch(`https://en.wiktionary.org/api/rest_v1/page/definition/${lemma}`, {mode: 'cors'});\n    const entryOut = await dictEntry.json();\n    //console.log(entryOut.other)\n    \n    if (entryOut.other === undefined){\n        return \"Not Found\";\n    } else {\n        let def;\n        let defArr = entryOut.other[0].definitions;\n        \n        if(entryOut.other[0].definitions.length === 1){\n            def = entryOut.other[0].definitions[0].definition;\n            \n        } else {\n            for(let i = 0; i < defArr.length; i++ ){\n                def = def + defArr[i].definition; \n            }\n        }\n        let fixedDef = def.replace(/<(.*?)>/g, ' ');\n        let betterDef = fixedDef.replace(/undefined/g, '');\n            \n        return betterDef;\n    }\n};\n\nconst getPerseusGreek = async (lemma) => { // retrieves the XML from the Perseus API and formats it to a human-readable state\n    const beta = greekToBetaCode(lemma);\n    \n    let dataAsJson = {};\n    const data = await fetch(`https://www.perseus.tufts.edu/hopper/xmlchunk?doc=Perseus%3Atext%3A1999.04.0058%3Aentry%3D${beta}`);\n    const textData = await data.text();\n\n    if (textData.indexOf('An Error Occurred') > -1) {\n        const data1 = await fetch(`https://www.perseus.tufts.edu/hopper/xmlchunk?doc=Perseus%3Atext%3A1999.04.0058%3Aentry%3D${beta}1`);\n        const textData1 = await data1.text();\n        if (textData1.indexOf('An Error Occurred') > -1) {\n            return \"Can't Find Entry\";\n        } else {\n            dataAsJson = JSON.parse(convert.xml2json(textData1, {compact: true, spaces: 4}));\n            const lower = dataAsJson[\"TEI.2\"].text.body.div0.entry.sense;\n        let defArray = [];\n        for(let i = 0; i < lower.length; i++){\n            const flatter = flatten(lower[i]);\n            //console.log(flatter);\n            let regex1 = /^_text.0/;\n            let regex2 = /_text$/\n            let regex3 = /^foreign./;\n            let regex4 = /^usg./;\n\n            const asArray = Object.entries(flatter);\n            const allowedArr = asArray.filter(([key, value]) => (((regex1.test(key) || regex2.test(key)) && (!regex3.test(key) && !regex4.test(key)) && (value !== \", \" && value !== \"; \" && value !== \":\"))));\n            const allowedObj = Object.fromEntries(allowedArr);\n    \n            for (const [key, value] of Object.entries(allowedObj)) {\n                allowedObj[key] = value.replace(/^\\s/g, '');\n                allowedObj[key] = value.replace(/,\\s$/, ':');\n            }\n    \n            defArray.push(allowedObj);\n        }\n        \n        let joined = '';\n        for(let i = 0; i < defArray.length; i++) {\n            let subArr = Object.entries(defArray[i]);\n            const endArr = subArr.map(([key, value]) => (value) )\n            const endStr = endArr.join(', ');\n            \n            joined += endStr;\n        }\n        return joined;\n        } \n    } else {\n        dataAsJson = JSON.parse(convert.xml2json(textData, {compact: true, spaces: 4}));\n        \n        const lower = dataAsJson[\"TEI.2\"].text.body.div0.entry.sense;\n        \n        let defArray = [];\n        \n        for(let i = 0; i < lower.length; i++){\n            \n            const flatter = flatten(lower[i]);\n            \n            //console.log(flatter);\n            let regex1 = /^_text.0/;\n            let regex2 = /_text$/\n            let regex3 = /^foreign./;\n            let regex4 = /^usg./;\n\n            const asArray = Object.entries(flatter);\n            \n            const allowedArr = asArray.filter(([key, value]) => (((regex1.test(key) || regex2.test(key)) && (!regex3.test(key) && !regex4.test(key) && value !== \", \" && value !== \":\"))));\n            // (    && value !== \"; \") \n            \n            const allowedObj = Object.fromEntries(allowedArr);\n            \n            for (const [key, value] of Object.entries(allowedObj)) {\n                allowedObj[key] = value.replace(/^\\s/g, '');\n                allowedObj[key] = value.replace(/,\\s$/, ':');\n            }\n    \n            defArray.push(allowedObj);\n        }\n        \n        let joined = '';\n        for(let i = 0; i < defArray.length; i++) {\n            let subArr = Object.entries(defArray[i]);\n            const endArr = subArr.map(([key, value]) => (value) )\n            const endStr = endArr.join(', ');\n            \n            joined += endStr;\n        }\n        // console.log(joined);\n        return joined;\n    }\n};\n\nexport default getGreekMorph;","const convert = require('xml-js');\nconst flatten = require('flat');\n\n\nconst getLatinMorph = async (lemma) => { //returns a full array of relevant information relating to the morphology, including the headword, part of speech, inflection possibilities, Wiktionary Def, and Lewis & Short entry\n    const latinData = await fetch(`https://services.perseids.org/bsp/morphologyservice/analysis/word?lang=lat&engine=morpheuslat&word=${lemma}`, {mode: 'cors'})\n    const dataOut = await latinData.json();\n    const body = dataOut.RDF.Annotation.Body;\n\n    if (body === undefined) {\n        console.log('undefined');\n    }\n    //console.log(dataOut);\n    if(Array.isArray(body)) {\n        let retArr = [];\n        for(let i = 0; i < body.length; i++){\n            const inflectArr = body[i].rest.entry.infl;\n            let headWord = body[i].rest.entry.dict.hdwd.$;\n            let fixedHead = headWord.replace(/[1-9]/g, '');\n            const type = body[i].rest.entry.dict.pofs.$;\n            const inflect = getLatininflectArr(inflectArr, type);\n            const shortDict = await getWikiLatin(fixedHead);\n            const longDict = await getPerseusLatin(fixedHead);\n            let subObj = {};\n            let check = false; \n            \n            if(inflect === undefined){ // if word is not inflected, returns array without inflectArr (numerals, particles, etc.)\n                subObj = {\n                    headword: fixedHead, \n                    type: type, \n                    inflections: [\n                        {\n                            inflections: \"uninflected\"\n                        }\n                    ], \n                    shortDef: shortDict,\n                    longDef: longDict\n                };\n            } else {\n                subObj = {\n                    headword: fixedHead, \n                    type: type, \n                    inflections: inflect,\n                    shortDef: shortDict,\n                    longDef: longDict\n                };\n            }\n            \n            //console.log(setArr);\n            \n            for(let i = 0; i < retArr.length; i++) {\n                    if(JSON.stringify(subObj) === JSON.stringify(retArr[i])){\n                        check = true;\n                    }\n            }\n            if(check === false) {\n                \n                retArr[i] = (subObj);\n            }\n        }\n        \n\n    return retArr;\n    } else {\n        const inflectArr = body.rest.entry.infl;\n        let headWord = body.rest.entry.dict.hdwd.$;\n        let fixedHead = headWord.replace(/[1-9]/g, '');\n        //console.log(fixedHead);\n        const type = body.rest.entry.dict.pofs.$;\n        const inflect = getLatininflectArr(inflectArr, type);\n        const shortDict = await getWikiLatin(fixedHead);\n        const longDict = await getPerseusLatin(fixedHead);\n        //console.log(inflect);\n        if(inflect === undefined){ // as before, if word is not inflected, returns array without inflectArr (numerals, particles, etc.)\n            //console.log(\"UND\");\n            return [{\n                    headword: fixedHead, \n                    type: type, \n                    inflections: [\n                        {\n                            inflection: 'uninflected'\n                        }\n                    ], \n                    shortDef: shortDict,\n                    longDef: longDict\n            }];\n        } else {\n            return [{   \n                headword: fixedHead,\n                type: type,\n                inflections: inflect,\n                shortDef: shortDict,\n                longDef: longDict\n            }];\n        }  \n    }\n};\n\nconst getLatininflectArr = (inflectArr, type) => {\n    //console.log(inflectArr, type); \n    let returnArr = [];\n    if(type === 'verb') {\n        if(Array.isArray(inflectArr)){\n            for(let i = 0; i < inflectArr.length; i++){\n                if(inflectArr[i].mood.$ === 'participle'){\n                    let gender = inflectArr[i].gend.$;\n                    let latCase = inflectArr[i].case.$;\n                    let number = inflectArr[i].num.$;\n                    let latTense = inflectArr[i].tense.$;\n                    let latMood = inflectArr[i].mood.$;\n                    let subObj = {\n                        inflection: `${gender} ${latCase} ${number} ${latTense} ${latMood}`\n                    }\n                    returnArr[i] = subObj\n                } else if(inflectArr[i].mood.$ === 'infinitive'){\n                    let latTense = inflectArr[i].tense.$;\n                    let latVoice = inflectArr[i].voice.$;\n                    let latMood = inflectArr[i].mood.$;\n                    let subObj = {\n                        inflection: `${latTense} ${latVoice} ${latMood}`\n                    }\n                    returnArr[i] = (subObj);\n                } else {\n                    let person = inflectArr[i].pers.$;\n                    let number = inflectArr[i].num.$;\n                    let latTense = inflectArr[i].tense.$;\n                    let latVoice = inflectArr[i].voice.$;\n                    let latMood = inflectArr[i].mood.$;\n                    let subObj = {\n                        inflection: `${person} person ${number} ${latTense} ${latVoice} ${latMood}`\n                    }\n                    returnArr[i] = (subObj);\n                }\n            }   \n            return returnArr;\n        } else {\n            if(inflectArr.mood.$ === 'infinitive') {\n                let latTense = inflectArr.tense.$;\n                let latVoice = inflectArr.voice.$;\n                let latMood = inflectArr.mood.$;\n\n                return [{\n                    inflection: `${latTense} ${latVoice} ${latMood}`\n                }];\n            } else if (inflectArr.mood.$ === 'participle') {\n                let gender = inflectArr.gend.$;\n                let latCase = inflectArr.case.$;\n                let number = inflectArr.num.$;\n                let latTense = inflectArr.tense.$;\n                let latMood = inflectArr.mood.$;\n                return [{\n                    inflection: `${gender} ${latCase} ${number} ${latTense} ${latMood}`\n                }]\n            }\n            \n            else {\n                let person = inflectArr.pers.$;\n                let number = inflectArr.num.$;\n                let latTense = inflectArr.tense.$;\n                let latVoice = inflectArr.voice.$;\n                let latMood = inflectArr.mood.$;\n\n                return [{\n                    inflection: `${person} person ${number} ${latTense} ${latVoice} ${latMood}`\n                }];\n            }\n        }\n    } else if(type === 'noun') {\n        if(Array.isArray(inflectArr)){\n            for(let i = 0; i < inflectArr.length; i++){\n                let gender = inflectArr[i].gend.$;\n                let latCase = inflectArr[i].case.$;\n                let number = inflectArr[i].num.$;\n                let declension = inflectArr[i].decl.$;\n                let conj = {\n                    declension: declension,\n                    inflection: `${gender} ${latCase} ${number}`\n                }\n            \n                returnArr[i] = (conj);\n            }   \n            return returnArr;\n        } else {\n            let gender = inflectArr.gend.$;\n            let latCase = inflectArr.case.$;\n            let number = inflectArr.num.$;\n            let declension = inflectArr.decl.$;\n            \n            return [{\n                declension: declension,\n                inflection: `${gender} ${latCase} ${number}`\n            }];\n        }\n    } else if(type === 'adjective') {\n        if(Array.isArray(inflectArr)) {\n            for(let i = 0; i < inflectArr.length; i++) {\n                if(inflectArr[i].gend.$ === 'adverbial') {\n                    let declension = inflectArr[i].decl.$;\n                    let gender = inflectArr[i].gend.$;\n                    let conj = {\n                        declension: declension,\n                        inflection: gender\n                    }\n\n                    returnArr[i] = (conj);\n                } else {\n                    let gender = inflectArr[i].gend.$;\n                    let latCase = inflectArr[i].case.$;\n                    let number = inflectArr[i].num.$;\n                    let declension = inflectArr[i].decl.$;\n                    let conj = {\n                        declension: declension,\n                        inflection: `${gender} ${latCase} ${number}`\n                    }\n                    returnArr[i] = (conj);\n                }\n            }   \n            return returnArr;\n        } else {\n            if(inflectArr.gend.$ === 'adverbial') {\n                let declension = inflectArr.decl.$;\n                let gender = inflectArr.gend.$;\n                return [{\n                    declension: declension,\n                    inflection: gender\n                }];\n            } else {\n                let gender = inflectArr.gend.$;\n                let latCase = inflectArr.case.$;\n                let number = inflectArr.num.$;\n                let declension = inflectArr.decl.$;\n                returnArr = [`${declension} declension`, `${gender} ${latCase} ${number}`];\n                return [{\n                    declension: declension,\n                    inflection: `${gender} ${latCase} ${number}`\n                }];\n            }\n        } \n    } else if(type === 'pronoun') {\n        if(Array.isArray(inflectArr)){\n            for(let i = 0; i < inflectArr.length; i++){\n                let gender = inflectArr[i].gend.$;\n                let latCase = inflectArr[i].case.$;\n                let number = inflectArr[i].num.$;\n                let conj = {\n                    inflection: `${gender} ${latCase} ${number}`\n                }\n            \n                returnArr[i] = (conj);\n            }   \n            return returnArr;\n        } else {\n            let gender = inflectArr.gend.$;\n            let latCase = inflectArr.case.$;\n            let number = inflectArr.num.$;\n            \n            return [{\n                inflection: `${gender} ${latCase} ${number}`\n            }];\n        }\n    }\n};\n\nconst getWikiLatin = async (lemma) => {\n    const latinDef = await fetch (`https://en.wiktionary.org/api/rest_v1/page/definition/${lemma}?redirect=true`);\n    const defOut = await latinDef.json();\n    const defOut_Latin = defOut.la[0];\n    \n    let defHTML = defOut_Latin.definitions[0].definition;\n\n    document.getElementById('latin').innerHTML = defHTML;\n    let titles = document.querySelectorAll('#latin a');\n    let sumDef = `${titles[0].textContent}`;\n    for(let i = 1; i < titles.length; i++){\n        sumDef = sumDef + `, ${titles[i].textContent}`;\n    }\n\n    return sumDef;\n};\n\nconst getPerseusLatin = async (lemma) => {\n    let dataAsJson = {};\n    const data = await fetch(`https://www.perseus.tufts.edu/hopper/xmlchunk?doc=Perseus%3Atext%3A1999.04.0060%3Aentry%3D${lemma}`);\n    const textData = await data.text();\n    \n\n    if (textData.indexOf('An Error Occurred') > -1){\n        const data1 = await fetch(`https://www.perseus.tufts.edu/hopper/xmlchunk?doc=Perseus%3Atext%3A1999.04.0060%3Aentry%3D${lemma}1`);\n        const textData1 = await data1.text();\n        if (textData1.indexOf('An Error Occurred') > -1){\n            return \"Can't Find Entry\";\n        } else {\n            dataAsJson = JSON.parse(convert.xml2json(textData1, {compact: true, spaces: 4}));\n            const lower = dataAsJson[\"TEI.2\"].text.body.div0.entry.sense;\n            let defArray = [];\n            for(let i = 0; i < lower.length; i++){\n                const flatter = flatten(lower[i]);\n                //console.log(flatter);\n                let regex1 = /^_text.0/;\n                let regex2 = /_text$/\n                let regex3 = /^foreign./;\n                let regex4 = /^usg./;\n\n                const asArray = Object.entries(flatter);\n                const allowedArr = asArray.filter(([key, value]) => (((regex1.test(key) || regex2.test(key)) && (!regex3.test(key) && !regex4.test(key)) && (value !== \", \" && value !== \"; \" && value !== \":\"))));\n                const allowedObj = Object.fromEntries(allowedArr);\n        \n                for (const [key, value] of Object.entries(allowedObj)) {\n                    allowedObj[key] = value.replace(/^\\s/g, '');\n                    allowedObj[key] = value.replace(/,\\s$/, ':');\n                }\n        \n                defArray.push(allowedObj);\n            }\n        \n            let joined = '';\n            for(let i = 0; i < defArray.length; i++) {\n                let subArr = Object.entries(defArray[i]);\n                const endArr = subArr.map(([key, value]) => (value) )\n                const endStr = endArr.join(', ');\n                \n                joined += endStr;\n            }\n            return joined;\n        }\n    } else {\n        dataAsJson = JSON.parse(convert.xml2json(textData, {compact: true, spaces: 4}));\n        \n        const lower = dataAsJson[\"TEI.2\"].text.body.div0.entry.sense;\n        //console.log(lower);\n        let defArray = [];\n        let joined = '';\n        if(Array.isArray(lower)){\n            for(let i = 0; i < lower.length; i++){\n            \n                const flatter = flatten(lower[i]);\n                \n                //console.log(flatter);\n                let regex1 = /^_text.0/;\n                let regex2 = /_text$/\n                let regex3 = /^foreign./;\n                let regex4 = /^usg./;\n    \n                const asArray = Object.entries(flatter);\n                \n                const allowedArr = asArray.filter(([key, value]) => (((regex1.test(key) || regex2.test(key)) && (!regex3.test(key) && !regex4.test(key) && value !== \", \" && value !== \":\"))));\n                // (    && value !== \"; \") \n                \n                const allowedObj = Object.fromEntries(allowedArr);\n                \n                for (const [key, value] of Object.entries(allowedObj)) {\n                    allowedObj[key] = value.replace(/^\\s/g, '');\n                    allowedObj[key] = value.replace(/,\\s$/, ':');\n                }\n        \n                defArray.push(allowedObj);\n            }\n            \n            \n            for(let i = 0; i < defArray.length; i++) {\n                let subArr = Object.entries(defArray[i]);\n                const endArr = subArr.map(([key, value]) => (value) )\n                const endStr = endArr.join(', ');\n                \n                joined += endStr;\n            }\n        } else {\n            const flatter = flatten(lower);\n            //console.log(flatter);\n            let regex1 = /^_text.0/;\n            let regex2 = /_text$/\n            let regex3 = /^foreign./;\n            let regex4 = /^usg./;\n\n            const asArray = Object.entries(flatter);\n            const allowedArr = asArray.filter(([key, value]) => (((regex1.test(key) || regex2.test(key)) && (!regex3.test(key) && !regex4.test(key) && value !== \", \" && value !== \":\"))));\n                // (    && value !== \"; \") \n                \n            const allowedObj = Object.fromEntries(allowedArr);\n            \n            for (const [key, value] of Object.entries(allowedObj)) {\n                allowedObj[key] = value.replace(/^\\s/g, '');\n                allowedObj[key] = value.replace(/,\\s$/, ':');\n            }\n            console.log(allowedObj);\n            let subArr = Object.entries(allowedObj);\n            const endArr = subArr.map(([key, value]) => (value) )\n            const endStr = endArr.join(', ');\n            \n            joined = endStr;\n        }\n        \n        // console.log(joined);\n        return joined;\n        //console.log(dataAsJson);\n        //need to do some pretty serious parsing here. This could take a while.\n        \n    }\n\n};\n\n\nexport default getLatinMorph","import '../modules/css/translation.css';\n\nconst Translation = (props) => {\n\n    const format = (item, i) => { // maps through the inflection array and returns a div containing each inflection \n\n            return(\n                <div className=\"infl\">\n                <h4 className=\"possibility\">Possibility {i + 1}</h4>\n                {Object.keys(item).map((val, i) => {\n                    return (\n                        <div className='inflect' key={i}>\n                        <div>{val.charAt(0).toUpperCase() + val.slice(1)}: {item[val]}</div>\n                        <br/>\n                        </div>)\n                        })}\n                </div>\n            )\n    }\n    return (\n        <div className='trans-container'>\n            <h2 className=\"title\">{props.provided}</h2> \n            <div className=\"type\">{props.type}</div><br/>\n            <div className=\"head\">{props.head}</div><br/>\n            <div className=\"short\">{props.short}</div><br/>\n            <div>{(props.provided !== '') ? '––––––––––––––––––––' : ''}</div>\n            <div>{props.inflections.map((item, i) => format(item, i))}</div>\n            <div>{(props.provided !== '') ? '––––––––––––––––––––' : ''}</div><br/>\n            <div className=\"long\">{props.long}</div>\n            <br/>\n            <br/>\n        </div>    \n    )\n}\n\nexport default Translation\n","import Translation from './Translation';\n\nconst Mult = ({ input, provided, lang }) => { \n    // maps through the input array and provides a Translation component from the information inside input\n    return (\n        <>\n            {input.map((el, index) => {return ( \n                <Translation \n                    key={index}\n                    provided={provided}\n                    head={`From: ${el.headword}`} \n                    type={el.type.charAt(0).toUpperCase() + el.type.slice(1)} \n                    inflections={el.inflections} \n                    short={`Wiki Definition: ${el.shortDef}`} \n                    long={(el.lang === 'la') ? `Lewis & Short Entry: ${el.longDef}` : `Liddell Scott Entry: ${el.longDef}`} \n                />\n            )})}\n        </>\n    )\n}\n\nexport default Mult\n","import React, { useState, useEffect } from 'react';\nimport getGreekMorph from './modules/javascript/greek';\nimport getLatinMorph from './modules/javascript/latin';\nimport Mult from './components/Mult';\nimport {Button} from '@material-ui/core';\nimport './App.css';\n\nfunction App () {\n\n  const [greek, setGreek] = useState (''); // the current value of the greek input string\n  const [latin, setLatin] = useState (''); // the current value of the latin input string\n  const [language, setLanguage] = useState(''); // the most recent language submitted by the user\n\n  const [greekArr, setGreekArr] = useState([]); // array of words from the user's input in the Greek input form\n  const [latinArr, setLatinArr] = useState([]); // array of words from the user's input in the Latin input form\n  const [displayArr, setDisplayArr] = useState([]); // the final array of words to be displayed... will be either Greek or Latin\n  const [morphList, setMorphList] = useState([]); // an array of morphs corresponding to each item in either greekArr or latinArr, depending on which the user submitted\n\n  const [visible, setVisible] = useState(false); // determines whether or not a morph is visible on the screen during mouseEnter and before mouseLeave\n  const [active, setActive] = useState(false);  // determines wheter or not a morph is visible after a click, remaining even after mouseLeave\n  const [activeIndex, setActiveIndex] = useState(); // the index of the currently active morph (so in 'cogito ergo sum', if 'ergo' were active this value would be '1')\n\n  const [loaded, setLoaded] = useState(false); // changes to true once the morphList for a given input phrase by the user has been properly returned\n\n  useEffect(() => { // whenever the user updates the greek array by inputting some string of greek text, this function retrieves the morphology information for all words in the array.\n    async function getGreekPhrase() {\n    let arr = [];\n    if (greekArr !== []) {\n      for (let i = 0; i < greekArr.length; i++) {\n        let word = await getGreekMorph (greekArr[i]);\n        arr.push(word);\n      } \n    setMorphList(arr);\n    setLoaded(true);\n    } else if (greekArr.length === 1) {\n        let grekWord = await getGreekMorph(greekArr[0])\n        setMorphList(grekWord); \n        setLoaded(true);\n      }\n    }\n    getGreekPhrase();\n  }, [greekArr])\n\n  useEffect(() => { // this works exactly the same as the getGreekPhrase function in the previous hook.\n    async function getLatinPhrase() {\n    let arr = [];\n    if (latinArr !== []) {\n      for (let i = 0; i < latinArr.length; i++) {\n        let word = await getLatinMorph (latinArr[i]);\n        arr.push(word);\n      } \n    setMorphList(arr);\n    setLoaded(true);\n      \n    } else if (latinArr.length === 1) {\n        let latWord = await getLatinMorph(latinArr[0])\n        setMorphList(latWord); \n        setLoaded(true);\n      }\n    }\n    getLatinPhrase();\n  }, [latinArr])\n\n  useEffect(() => { // if the morphList change (the full list of morphology items for the user's input string), it sets the display array to be either Greek or Latin depending on what the user input.\n    if (language === 'la') {setDisplayArr(latinArr)}\n    if (language === 'gr') {setDisplayArr(greekArr)}\n  }, [morphList])\n\n  const displayMorph = (e, index) => { // this is what sets whether or not the morphs may display on the page. Only works when certain conditions are satisfied.\n    if (index !== activeIndex && loaded === true) {\n      setActiveIndex(index);\n      setVisible(true);\n      setActive(false);\n    }\n  }\n\n  const setClicked = (e, index) => { // if any word is clicked, this sets the morph for that word to remain on the screen even after mouseLeave\n    setActiveIndex(index);\n    setVisible(true);\n    setActive(true);\n  }\n\n  const stopDisplay = (e, index) => { // controls the removal of the display on mouseLeave from one of the words of the displayed string\n    if (active !== true && loaded === true) {\n      setVisible(false)\n      setActiveIndex();\n    }\n  }\n\n  const handleChange = (e, lang) => { // updates 'greek' or 'latin' in state as the user types in one of the input boxes\n    if (lang === 'greek') {\n      setGreek(e.target.value);\n    }\n    if (lang === 'latin') {\n      setLatin(e.target.value);\n    }\n  }\n\n  const handleLang = (e, lang) => { // handles user submission of either greek or latin forms\n    if (lang === 'greek') {\n      setLoaded(false);\n      setVisible(false)\n      setActiveIndex();\n      setActive(false);\n      setLanguage('gr');\n      let cleaned = greek.replace(/,/g, '');\n      setGreekArr(cleaned.split(' '));\n    }\n    if (lang === 'latin') {\n      setLoaded(false);\n      setVisible(false)\n      setActiveIndex();\n      setActive(false);\n      setLanguage('la');\n      let cleaned = latin.replace(/,/g, '');\n      setLatinArr(cleaned.split(' '));\n      //lat(latin)\n    }\n    e.preventDefault();\n  }\n\n    return (\n      <div>\n        <div id=\"form-container\">\n          <form \n            className=\"lang-form\" \n            onSubmit={(e) => {handleLang(e, 'greek')}}>\n              <input \n                className=\"lang-input\" \n                type=\"text\" value={greek} \n                onChange={(e) => {handleChange(e, 'greek')}} \n                name=\"gr\" \n                placeholder=\"ἄνδρα\"/>\n              &nbsp;\n              <Button \n                variant=\"outlined\" \n                color=\"primary\" \n                type=\"submit\" \n                classes={{label: 'sub-button'}}\n              >Submit Greek\n              </Button>\n          </form>\n          <form \n            className=\"lang-form\" \n            onSubmit={(e) => {handleLang(e, 'latin')}}>\n              <input \n                className=\"lang-input\" \n                type=\"text\" \n                value={latin} \n                onChange={(e) => {handleChange(e, 'latin')}} \n                placeholder=\"aequitas\"/>\n              &nbsp;\n              <Button \n                variant=\"outlined\" \n                color=\"secondary\" \n                type=\"submit\" \n                classes={{label: 'sub-button'}}\n                >Submit Latin\n              </Button>\n          </form>\n        </div>\n        <div className='phrase-container'>\n          {displayArr.map((el, index) => (\n            <div \n              className='phrase-word' \n              key={index} \n              onMouseDown={(e) => {setClicked(e, index)}} \n              onMouseEnter={(e) => {displayMorph(e, index)}} \n              onMouseLeave={(e) => {stopDisplay(e, index)}}>{el}\n            </div>\n          ))}\n        </div>\n        <br/>\n          {language === 'gr' ? (visible ? \n            <div id='translation'>\n              <Mult \n                input={morphList[activeIndex]} \n                provided={greekArr[activeIndex]} \n                lang={language}\n              />\n            </div> : '') : ''}\n          {language === 'la' ? (visible ? \n            <div id='translation'>\n              <Mult \n                input={morphList[activeIndex]} \n                provided={latinArr[activeIndex]} \n                lang={language}\n              />\n            </div> : '') : ''}\n          <div id='greek'></div>\n          <div id='latin'></div>\n      </div>\n    );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\n"],"sourceRoot":""}