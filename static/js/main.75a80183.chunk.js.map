{"version":3,"sources":["modules/javascript/greek.js","modules/javascript/latin.js","components/Translation.js","components/Mult.js","App.js","index.js"],"names":["greekdict","require","getGreekMorph","lemma","a","fetch","mode","greekData","json","dataOut","undefined","body","RDF","Annotation","Body","Error","returnArr","Array","isArray","subObj","i","length","type","rest","entry","infl","pofs","$","inflections","headWord","dict","hdwd","fixedHead","replace","inflect","getGreekInflections","getWikiGreek","shortDict","longDict","getLocalDict","headword","dialect","shortDef","longDef","inflection","console","error","inflectArr","combinedArr","mood","tense","voice","dial","person","pers","number","num","gender","gend","grekCase","case","nCase","declension","decl","dictEntry","entryOut","other","defArr","definitions","def","definition","fixedDef","betterDef","latindict","getLatinMorph","latinData","retArr","getLatininflectArr","getWikiLatin","check","JSON","stringify","latCase","latTense","latMood","latVoice","conj","latinDef","defOut","defOut_Latin","la","defHTML","document","getElementById","innerHTML","titles","querySelectorAll","sumDef","textContent","dictSense","senses","combined","newArr","concat","join","Translation","key","provided","head","short","long","expanded","executeOnClick","className","map","item","Object","keys","val","charAt","toUpperCase","slice","format","anchorClass","lines","more","less","onClick","Mult","input","lang","setExpanded","isExpanded","el","index","App","useState","greek","setGreek","latin","setLatin","language","setLanguage","greekArr","setGreekArr","latinArr","setLatinArr","displayArr","setDisplayArr","morphList","setMorphList","visible","setVisible","active","setActive","loaded","setLoaded","loadingBar","setLoadingBar","activeIndex","setActiveIndex","isMobile","useMediaQuery","query","useEffect","arr","word","push","grekWord","getGreekPhrase","latWord","getLatinPhrase","log","handleChange","e","target","value","handleLang","cleanedArr","trim","split","preventDefault","id","onSubmit","onChange","name","placeholder","Button","variant","color","classes","label","onMouseDown","setClicked","onMouseEnter","displayMorph","onMouseLeave","style","height","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.75a80183.chunk.js","sourcesContent":["import {  greekToBetaCode  } from 'beta-code-js'; // previously used in getPerseusGreek() for Perseus's awful beta-code Greek entry\nconst convert = require('xml-js'); // previously used to convert XML from Perseus into poorly-formatted JSON\nconst flatten = require('flat'); // previously used to clean the poorly-formatted JSON from Perseus into slightly better formatted JSON, but still bad\nconst greekdict = require('./json/lsj.json');\n\nconst getGreekMorph = async (lemma) => { //returns a full array of relevant information relating to the morphology, including the headword, part of speech, inflection possibilities, Wiktionary Def, and LSJ Def\n    // console.log(greekdict.λύω);\n    // console.log(typeof(greekdict.λύω));\n    // fetches the given greek string from the morphology service\n    try {\n        const greekData = await fetch(`https://services.perseids.org/bsp/morphologyservice/analysis/word?lang=grc&engine=morpheusgrc&word=${lemma}`, {mode: 'cors'});\n        const dataOut = await greekData.json();\n        const body = dataOut.RDF.Annotation.Body;\n        //console.log(dataOut);\n        if(body === undefined){\n            throw new Error ('New Exception');\n        }\n        let type;\n        let returnArr = [];\n        if(Array.isArray(body)){ // if multiple possible definitions, returns morphology array for each\n            let subObj = {};\n            for(let i = 0; i < body.length; i++){\n                if(dataOut.RDF.Annotation.Body[i].rest.entry.infl[0] !== undefined){\n                    type = (dataOut.RDF.Annotation.Body[i].rest.entry.infl[0].pofs.$);\n                } else {\n                    type = dataOut.RDF.Annotation.Body[i].rest.entry.infl.pofs.$;\n                }\n                const inflections = dataOut.RDF.Annotation.Body[i].rest.entry.infl;\n                let headWord = dataOut.RDF.Annotation.Body[i].rest.entry.dict.hdwd.$;\n                let fixedHead = headWord.replace(/[1-9]/g, '');\n                const inflect = getGreekInflections(inflections, type);\n                const shortDict = await getWikiGreek(fixedHead);\n                const longDict = getLocalDict(fixedHead);\n                //const longDict = await getPerseusGreek(fixedHead);\n\n                //console.log(shortDict);\n\n                if(inflect === undefined){ // iff word is not inflected, returns array without inflections (numerals, particles, etc.)\n                    subObj = {\n                                headword: fixedHead, \n                                type: type, \n                                inflections: [\n                                    {\n                                        dialect: \"n/a\",\n                                        inflections: \"uninflected\"\n                                    }\n                                ], \n                                shortDef: shortDict,\n                                longDef: longDict\n                            };\n                } else {\n                    subObj = {\n                        headword: fixedHead, \n                        type: type, \n                        inflections: inflect,\n                        shortDef: shortDict,\n                        longDef: longDict\n                    };\n                }\n                returnArr[i] = subObj;\n            }\n            \n            return returnArr; //full array of word possibilities based on each possible root headword from input word\n\n        } else { //if there is only one root headword possible\n            \n            if(dataOut.RDF.Annotation.Body.rest.entry.infl[0] !== undefined){\n                type = (dataOut.RDF.Annotation.Body.rest.entry.infl[0].pofs.$);\n            } else {\n                type = dataOut.RDF.Annotation.Body.rest.entry.infl.pofs.$;\n            }\n        \n            const inflections = dataOut.RDF.Annotation.Body.rest.entry.infl;\n            let headWord = dataOut.RDF.Annotation.Body.rest.entry.dict.hdwd.$;\n            let fixedHead = headWord.replace(/[1-9]/g, '');\n            const inflect = getGreekInflections(inflections, type);\n            const shortDict = await getWikiGreek(fixedHead);\n            const longDict = getLocalDict(fixedHead);\n            //const longDict = await getPerseusGreek(fixedHead);\n\n            if(inflect === undefined){ // as before, if word is not inflected, returns array without inflections (numerals, particles, etc.)\n                return [{\n                        headword: fixedHead, \n                        type: type, \n                        inflections: [\n                            {\n                                dialect: 'n/a',\n                                inflection: 'uninflected'\n                            }\n                        ], \n                        shortDef: shortDict,\n                        longDef: longDict\n                    }];\n            } else {\n                return [{   \n                        headword: fixedHead,\n                        type: type,\n                        inflections: inflect,\n                        shortDef: shortDict,\n                        longDef: longDict\n                    }];\n            }   \n        }\n\n    } catch {\n        console.error('Word Not Found');\n        return [{   \n            headword: 'Not Found',\n            type: 'Not Found',\n            inflections: [['Not Found']],\n            shortDef: 'Not Found',\n            longDef: 'Not Found'\n        }]\n    }\n    //console.log(dataOut);\n};\n\nconst getGreekInflections = (inflectArr, type) => { // returns an array in which each element is an object of the dialect type and inflection pattern\n\n    if (type === 'verb') { //all other if statements contain similar code that will change what is returned in the object, depending on word type.\n        if(Array.isArray(inflectArr)){ // if multiple inflection possibilities, returns array of all possible inflections. \n            let combinedArr = [];\n                for(let i = 0; i < inflectArr.length; i++){\n                    if (inflectArr[i].mood.$ === 'infinitive') {\n                        let tense = inflectArr[i].tense.$;\n                        let voice = inflectArr[i].voice.$;\n                        let mood = inflectArr[i].mood.$;\n                        if(inflectArr[i].dial){\n                            let dialect = inflectArr[i].dial.$;\n                            combinedArr[i] = {\n                                dialect: dialect,\n                                inflection: `${tense} ${voice} ${mood}`\n                            };\n                        }else {\n                            combinedArr[i] = {\n                                dialect: 'Attic',\n                                inflection: `${tense} ${voice} ${mood}`\n                            }\n                        }\n                    } else {\n                        let person = inflectArr[i].pers.$;\n                        let number = inflectArr[i].num.$;\n                        let tense = inflectArr[i].tense.$;\n                        let voice = inflectArr[i].voice.$;\n                        let mood = inflectArr[i].mood.$;\n                        if(inflectArr[i].dial){\n                            let dialect = inflectArr[i].dial.$;\n                            combinedArr[i] = {\n                                dialect: dialect,\n                                inflection: `${person} person ${number} ${tense} ${voice} ${mood}`\n                            };\n                        }else {\n                            combinedArr[i] = {\n                                dialect: 'Attic',\n                                inflection: `${person} person ${number} ${tense} ${voice} ${mood}`\n                            }\n                        }\n                    }\n                }\n            return combinedArr;\n        } else {\n            if (inflectArr.mood.$ === 'infinitive') {\n                let tense = inflectArr.tense.$;\n                let voice = inflectArr.voice.$;\n                let mood = inflectArr.mood.$;\n                if(inflectArr.dial){\n                    let dialect = inflectArr.dial.$;\n                    return [{\n                        dialect: dialect,\n                        inflection: `${tense} ${voice} ${mood}`\n                    }];\n                }else {\n                    return [{\n                        dialect: 'Attic',\n                        inflection: `${tense} ${voice} ${mood}`\n                    }];\n                }\n            } else {\n                let person = inflectArr.pers.$;\n                let number = inflectArr.num.$;\n                let tense = inflectArr.tense.$;\n                let voice = inflectArr.voice.$;\n                let mood = inflectArr.mood.$;\n                if(inflectArr.dial){\n                    let dialect = inflectArr.dial.$;\n                    return [{\n                        dialect: dialect,\n                        inflection: `${person} person ${number} ${tense} ${voice} ${mood}`\n                    }];\n                }else {\n                    return [{\n                        dialect: 'Attic',\n                        inflection: `${person} person ${number} ${tense} ${voice} ${mood}`\n                    }];\n                }\n            }\n            \n        }\n    } else if (type === 'verb participle') {\n        if(Array.isArray(inflectArr)){\n            let combinedArr = [];\n                for(let i = 0; i < inflectArr.length; i++){\n                    let gender = inflectArr[i].gend.$;\n                    let grekCase = inflectArr[i].case.$;\n                    let number = inflectArr[i].num.$;\n                    let tense = inflectArr[i].tense.$;\n                    let voice = inflectArr[i].voice.$;\n                    let mood = inflectArr[i].mood.$;\n                    if(inflectArr[i].dial){\n                        let dialect = inflectArr[i].dial.$;\n                        combinedArr[i] = {\n                            dialect: dialect, \n                            inflection: `${gender} ${grekCase} ${number} ${tense} ${voice} ${mood}`\n                        };\n                    } else {\n                        combinedArr[i] = {\n                            dialect: 'Attic',\n                            inflection: `${gender} ${grekCase} ${number} ${tense} ${voice} ${mood}`\n                        };\n                    }\n                }\n            return combinedArr;\n        } else {\n            let gender = inflectArr.gend.$;\n            let grekCase = inflectArr.case.$;\n            let number = inflectArr.num.$;\n            let tense = inflectArr.tense.$;\n            let voice = inflectArr.voice.$;\n            let mood = inflectArr.mood.$;\n            if(inflectArr.dial){\n                let dialect = inflectArr.dial.$;\n                return [{\n                    dialect: dialect, \n                    inflection: `${gender} ${grekCase} ${number} ${tense} ${voice} ${mood}`\n                }];\n            } else {\n                return [{\n                    dialect: 'Attic',\n                    inflection: `${gender} ${grekCase} ${number} ${tense} ${voice} ${mood}`\n                }];\n            }\n        }\n    } else if (type === 'noun') {\n        if(Array.isArray(inflectArr)){\n            let combinedArr = [];\n                for(let i = 0; i < inflectArr.length; i++){\n                    \n                    let gender = inflectArr[i].gend.$;\n                    let nCase = inflectArr[i].case.$;\n                    let number = inflectArr[i].num.$;\n                    let declension = inflectArr[i].decl.$;\n                    if(inflectArr[i].dial){\n                        let dialect = inflectArr[i].dial.$;\n                        combinedArr[i] = {\n                            dialect: dialect, \n                            declension: declension,\n                            inflection: `${gender} ${nCase} ${number}`\n                        };\n                    } else {\n                        combinedArr[i] = {\n                            dialect: 'Attic', \n                            declension: declension,\n                            inflection: `${gender} ${nCase} ${number}`\n                        };\n                    }\n                }\n            return combinedArr;\n        }\n        let gender = inflectArr.gend.$;\n        let nCase = inflectArr.case.$;\n        let number = inflectArr.num.$;\n        let declension = inflectArr.decl.$;\n        if(inflectArr.dial){\n            let dialect = inflectArr.dial.$;\n            return [{\n                dialect: dialect, \n                declension: declension,\n                inflection: `${gender} ${nCase} ${number}`\n            }];\n        } else {\n            return [{\n                dialect: 'Attic', \n                declension: declension,\n                inflection: `${gender} ${nCase} ${number}`\n            }];\n        }\n    } else if (type === 'adjective') {\n        if(Array.isArray(inflectArr)){\n            let combinedArr = [];\n                for(let i = 0; i < inflectArr.length; i++){\n                    \n                    let gender = inflectArr[i].gend.$;\n                    let nCase = inflectArr[i].case.$;\n                    let number = inflectArr[i].num.$;\n                    let declension = inflectArr[i].decl.$;\n                    if(inflectArr[i].dial){\n                        let dialect = inflectArr[i].dial.$;\n                        combinedArr[i] = {\n                            dialect: dialect, \n                            declension: declension,\n                            inflection: `${gender} ${nCase} ${number}`\n                        };\n                    } else {\n                        combinedArr[i] = {\n                            dialect: 'Attic',\n                            declension: declension,\n                            inflection: `${gender} ${nCase} ${number}`\n                        };\n                    }\n                }\n            return combinedArr;\n        }\n        let gender = inflectArr.gend.$;\n        let nCase = inflectArr.case.$;\n        let number = inflectArr.num.$;\n        let declension = inflectArr.decl.$;\n        if(inflectArr.dial){\n            let dialect = inflectArr.dial.$;\n            return [{\n                dialect: dialect, \n                declension: declension,\n                inflection: `${gender} ${nCase} ${number}`\n            }]; \n        } else {\n            return [{\n                dialect: 'Attic',\n                declension: declension,\n                inflection: `${gender} ${nCase} ${number}`\n            }];\n        }\n    } else if (type === 'pronoun') {\n        if(Array.isArray(inflectArr)){\n            let combinedArr = [];\n                for(let i = 0; i < inflectArr.length; i++){\n                    if(inflectArr[i].pers !== undefined) {\n                        let person = inflectArr[i].pers.$;\n                        let gender = inflectArr[i].gend.$;\n                        let nCase = inflectArr[i].case.$;\n                        let number = inflectArr[i].num.$;\n                        \n                        combinedArr[i] = {\n                            inflection: `${person} person ${gender} ${nCase} ${number}`\n                        };\n                    } else {\n                        let gender = inflectArr[i].gend.$;\n                        let nCase = inflectArr[i].case.$;\n                        let number = inflectArr[i].num.$;\n\n                        combinedArr[i] = {\n                            inflection: `${gender} ${nCase} ${number}`\n                        };\n                    }\n                    \n                }\n            return combinedArr;\n        } else {\n            let person = inflectArr.pers.$;\n            let gender = inflectArr.gend.$;\n            let nCase = inflectArr.case.$;\n            let number = inflectArr.num.$;\n            return [{\n                inflection: `${person} person ${gender} ${nCase} ${number}`\n            }];\n        }\n        \n    } else if (type === 'article') {\n        if(Array.isArray(inflectArr)){\n            let combinedArr = [];\n                for(let i = 0; i < inflectArr.length; i++){\n                    \n                    let gender = inflectArr[i].gend.$;\n                    let nCase = inflectArr[i].case.$;\n                    let number = inflectArr[i].num.$;\n                    if(inflectArr[i].dial){\n                        let dialect = inflectArr[i].dial.$;\n                        combinedArr[i] = {\n                            dialect: dialect, \n                            inflection: `${gender} ${nCase} ${number}`\n                        };\n                    } else {\n                        combinedArr[i] = {\n                            dialect: 'Attic', \n                            inflection: `${gender} ${nCase} ${number}`\n                        };\n                    }\n                }\n            return combinedArr;\n        }\n        let gender = inflectArr.gend.$;\n        let nCase = inflectArr.case.$;\n        let number = inflectArr.num.$;\n        if(inflectArr.dial){\n            let dialect = inflectArr.dial.$;\n            return [{\n                dialect: dialect, \n                inflection: `${gender} ${nCase} ${number}`\n            }];\n        } else {\n            return [{\n                dialect: 'Attic', \n                inflection: `${gender} ${nCase} ${number}`\n            }];\n        }\n    } \n\n    //Fix Relative Pronouns, numerals, etc...\n};\n\nconst getWikiGreek = async (lemma) => { // fetches the wiktionary definition for the input word\n    const dictEntry = await fetch(`https://en.wiktionary.org/api/rest_v1/page/definition/${lemma}`, {mode: 'cors'});\n    const entryOut = await dictEntry.json();\n    //console.log(entryOut.other)\n    \n    if (entryOut.other === undefined){\n        return \"Not Found\";\n    } else {\n        let def;\n        let defArr = entryOut.other[0].definitions;\n        \n        if(entryOut.other[0].definitions.length === 1){\n            def = entryOut.other[0].definitions[0].definition;\n            \n        } else {\n            for(let i = 0; i < defArr.length; i++ ){\n                def = def + defArr[i].definition; \n            }\n        }\n        let fixedDef = def.replace(/<(.*?)>/g, ' ');\n        let betterDef = fixedDef.replace(/undefined/g, '');\n            \n        return betterDef;\n    }\n};\n\n// deprecated function that retrieved dictionary information from perseus.tufts.edu\n// const getPerseusGreek = async (lemma) => { // retrieves the XML from the Perseus API and formats it to a human-readable state\n//     const beta = greekToBetaCode(lemma);\n    \n//     let dataAsJson = {};\n//     const data = await fetch(`https://www.perseus.tufts.edu/hopper/xmlchunk?doc=Perseus%3Atext%3A1999.04.0058%3Aentry%3D${beta}`);\n//     const textData = await data.text();\n\n//     if (textData.indexOf('An Error Occurred') > -1) {\n//         const data1 = await fetch(`https://www.perseus.tufts.edu/hopper/xmlchunk?doc=Perseus%3Atext%3A1999.04.0058%3Aentry%3D${beta}1`);\n//         const textData1 = await data1.text();\n//         if (textData1.indexOf('An Error Occurred') > -1) {\n//             return \"Can't Find Entry\";\n//         } else {\n//             dataAsJson = JSON.parse(convert.xml2json(textData1, {compact: true, spaces: 4}));\n//             const lower = dataAsJson[\"TEI.2\"].text.body.div0.entry.sense;\n//         let defArray = [];\n//         for(let i = 0; i < lower.length; i++){\n//             const flatter = flatten(lower[i]);\n//             //console.log(flatter);\n//             let regex1 = /^_text.0/;\n//             let regex2 = /_text$/\n//             let regex3 = /^foreign./;\n//             let regex4 = /^usg./;\n\n//             const asArray = Object.entries(flatter);\n//             const allowedArr = asArray.filter(([key, value]) => (((regex1.test(key) || regex2.test(key)) && (!regex3.test(key) && !regex4.test(key)) && (value !== \", \" && value !== \"; \" && value !== \":\"))));\n//             const allowedObj = Object.fromEntries(allowedArr);\n    \n//             for (const [key, value] of Object.entries(allowedObj)) {\n//                 allowedObj[key] = value.replace(/^\\s/g, '');\n//                 allowedObj[key] = value.replace(/,\\s$/, ':');\n//             }\n    \n//             defArray.push(allowedObj);\n//         }\n        \n//         let joined = '';\n//         for(let i = 0; i < defArray.length; i++) {\n//             let subArr = Object.entries(defArray[i]);\n//             const endArr = subArr.map(([key, value]) => (value) )\n//             const endStr = endArr.join(', ');\n            \n//             joined += endStr;\n//         }\n//         return joined;\n//         } \n//     } else {\n//         dataAsJson = JSON.parse(convert.xml2json(textData, {compact: true, spaces: 4}));\n        \n//         const lower = dataAsJson[\"TEI.2\"].text.body.div0.entry.sense;\n        \n//         let defArray = [];\n        \n//         for(let i = 0; i < lower.length; i++){\n            \n//             const flatter = flatten(lower[i]);\n            \n//             //console.log(flatter);\n//             let regex1 = /^_text.0/;\n//             let regex2 = /_text$/\n//             let regex3 = /^foreign./;\n//             let regex4 = /^usg./;\n\n//             const asArray = Object.entries(flatter);\n            \n//             const allowedArr = asArray.filter(([key, value]) => (((regex1.test(key) || regex2.test(key)) && (!regex3.test(key) && !regex4.test(key) && value !== \", \" && value !== \":\"))));\n//             // (    && value !== \"; \") \n            \n//             const allowedObj = Object.fromEntries(allowedArr);\n            \n//             for (const [key, value] of Object.entries(allowedObj)) {\n//                 allowedObj[key] = value.replace(/^\\s/g, '');\n//                 allowedObj[key] = value.replace(/,\\s$/, ':');\n//             }\n    \n//             defArray.push(allowedObj);\n//         }\n        \n//         let joined = '';\n//         for(let i = 0; i < defArray.length; i++) {\n//             let subArr = Object.entries(defArray[i]);\n//             const endArr = subArr.map(([key, value]) => (value) )\n//             const endStr = endArr.join(', ');\n            \n//             joined += endStr;\n//         }\n//         // console.log(joined);\n//         return joined;\n//     }\n// };\n\nconst getLocalDict = (lemma) => { // retrieves dictionary information from the local Greek lexicon file\n    let dictForm = greekdict[lemma];\n    let cleaned = dictForm.replace(/<(.*?)>/g, '').replace(/&nbsp;/g, ' ');\n\n    return cleaned;\n};\n\n\n\nexport default getGreekMorph;","const convert = require('xml-js'); // preiously converted XML from perseus into JSON, probably unnecessary now\nconst flatten = require('flat'); // previously flattened terrible JSON into only halfway-terrible JSON\nconst latindict = require('./json/lewis-short.json');\n\nconst getLatinMorph = async (lemma) => { //returns a full array of relevant information relating to the morphology, including the headword, part of speech, inflection possibilities, Wiktionary Def, and Lewis & Short entry\n    try {\n        const latinData = await fetch(`https://services.perseids.org/bsp/morphologyservice/analysis/word?lang=lat&engine=morpheuslat&word=${lemma}`, {mode: 'cors'})\n        const dataOut = await latinData.json();\n        const body = dataOut.RDF.Annotation.Body;\n    \n        if (body === undefined) {\n            throw new Error ('New Exception');\n        }\n        //console.log(dataOut);\n        if(Array.isArray(body)) {\n            let retArr = [];\n            for(let i = 0; i < body.length; i++){\n                const inflectArr = body[i].rest.entry.infl;\n                let headWord = body[i].rest.entry.dict.hdwd.$;\n                let fixedHead = headWord.replace(/[1-9]/g, '');\n                const type = body[i].rest.entry.dict.pofs.$;\n                const inflect = getLatininflectArr(inflectArr, type);\n                const shortDict = await getWikiLatin(fixedHead);\n                const longDict = getLocalDict(fixedHead);\n                // const longDict = await getPerseusLatin(fixedHead);\n                let subObj = {};\n                let check = false; \n                \n                if(inflect === undefined){ // if word is not inflected, returns array without inflectArr (numerals, particles, etc.)\n                    subObj = {\n                        headword: fixedHead, \n                        type: type, \n                        inflections: [\n                            {\n                                inflections: \"uninflected\"\n                            }\n                        ], \n                        shortDef: shortDict,\n                        longDef: longDict\n                    };\n                } else {\n                    subObj = {\n                        headword: fixedHead, \n                        type: type, \n                        inflections: inflect,\n                        shortDef: shortDict,\n                        longDef: longDict\n                    };\n                }\n                \n                //console.log(setArr);\n                \n                for(let i = 0; i < retArr.length; i++) {\n                        if(JSON.stringify(subObj) === JSON.stringify(retArr[i])){\n                            check = true;\n                        }\n                }\n                if(check === false) {\n                    \n                    retArr[i] = (subObj);\n                }\n            }\n            \n    \n        return retArr;\n        } else {\n            const inflectArr = body.rest.entry.infl;\n            let headWord = body.rest.entry.dict.hdwd.$;\n            let fixedHead = headWord.replace(/[1-9]/g, '');\n            //console.log(fixedHead);\n            const type = body.rest.entry.dict.pofs.$;\n            const inflect = getLatininflectArr(inflectArr, type);\n            const shortDict = await getWikiLatin(fixedHead);\n            const longDict = getLocalDict(fixedHead);\n            // const longDict = await getPerseusLatin(fixedHead);\n            //console.log(inflect);\n            if(inflect === undefined){ // as before, if word is not inflected, returns array without inflectArr (numerals, particles, etc.)\n                //console.log(\"UND\");\n                return [{\n                        headword: fixedHead, \n                        type: type, \n                        inflections: [\n                            {\n                                inflection: 'uninflected'\n                            }\n                        ], \n                        shortDef: shortDict,\n                        longDef: longDict\n                }];\n            } else {\n                return [{   \n                    headword: fixedHead,\n                    type: type,\n                    inflections: inflect,\n                    shortDef: shortDict,\n                    longDef: longDict\n                }];\n            }  \n        }\n    } catch {\n        console.error ('Word Not Found');\n        return [{   \n            headword: 'Not Found',\n            type: 'Not Found',\n            inflections: [['Not Found']],\n            shortDef: 'Not Found',\n            longDef: 'Not Found'\n        }]\n    }\n    \n};\n\nconst getLatininflectArr = (inflectArr, type) => { // returns an array of all possible inflections depending on the type of word given\n    //console.log(inflectArr, type); \n    let returnArr = [];\n    if(type === 'verb') {\n        if(Array.isArray(inflectArr)){\n            for(let i = 0; i < inflectArr.length; i++){\n                if(inflectArr[i].mood.$ === 'participle'){\n                    let gender = inflectArr[i].gend.$;\n                    let latCase = inflectArr[i].case.$;\n                    let number = inflectArr[i].num.$;\n                    let latTense = inflectArr[i].tense.$;\n                    let latMood = inflectArr[i].mood.$;\n                    let subObj = {\n                        inflection: `${gender} ${latCase} ${number} ${latTense} ${latMood}`\n                    }\n                    returnArr[i] = subObj\n                } else if(inflectArr[i].mood.$ === 'infinitive'){\n                    let latTense = inflectArr[i].tense.$;\n                    let latVoice = inflectArr[i].voice.$;\n                    let latMood = inflectArr[i].mood.$;\n                    let subObj = {\n                        inflection: `${latTense} ${latVoice} ${latMood}`\n                    }\n                    returnArr[i] = (subObj);\n                } else {\n                    let person = inflectArr[i].pers.$;\n                    let number = inflectArr[i].num.$;\n                    let latTense = inflectArr[i].tense.$;\n                    let latVoice = inflectArr[i].voice.$;\n                    let latMood = inflectArr[i].mood.$;\n                    let subObj = {\n                        inflection: `${person} person ${number} ${latTense} ${latVoice} ${latMood}`\n                    }\n                    returnArr[i] = (subObj);\n                }\n            }   \n            return returnArr;\n        } else {\n            if(inflectArr.mood.$ === 'infinitive') {\n                let latTense = inflectArr.tense.$;\n                let latVoice = inflectArr.voice.$;\n                let latMood = inflectArr.mood.$;\n\n                return [{\n                    inflection: `${latTense} ${latVoice} ${latMood}`\n                }];\n            } else if (inflectArr.mood.$ === 'participle') {\n                let gender = inflectArr.gend.$;\n                let latCase = inflectArr.case.$;\n                let number = inflectArr.num.$;\n                let latTense = inflectArr.tense.$;\n                let latMood = inflectArr.mood.$;\n                return [{\n                    inflection: `${gender} ${latCase} ${number} ${latTense} ${latMood}`\n                }]\n            }\n            \n            else {\n                let person = inflectArr.pers.$;\n                let number = inflectArr.num.$;\n                let latTense = inflectArr.tense.$;\n                let latVoice = inflectArr.voice.$;\n                let latMood = inflectArr.mood.$;\n\n                return [{\n                    inflection: `${person} person ${number} ${latTense} ${latVoice} ${latMood}`\n                }];\n            }\n        }\n    } else if(type === 'noun') {\n        if(Array.isArray(inflectArr)){\n            for(let i = 0; i < inflectArr.length; i++){\n                let gender = inflectArr[i].gend.$;\n                let latCase = inflectArr[i].case.$;\n                let number = inflectArr[i].num.$;\n                let declension = inflectArr[i].decl.$;\n                let conj = {\n                    declension: declension,\n                    inflection: `${gender} ${latCase} ${number}`\n                }\n            \n                returnArr[i] = (conj);\n            }   \n            return returnArr;\n        } else {\n            let gender = inflectArr.gend.$;\n            let latCase = inflectArr.case.$;\n            let number = inflectArr.num.$;\n            let declension = inflectArr.decl.$;\n            \n            return [{\n                declension: declension,\n                inflection: `${gender} ${latCase} ${number}`\n            }];\n        }\n    } else if(type === 'adjective') {\n        if(Array.isArray(inflectArr)) {\n            for(let i = 0; i < inflectArr.length; i++) {\n                if(inflectArr[i].gend.$ === 'adverbial') {\n                    let declension = inflectArr[i].decl.$;\n                    let gender = inflectArr[i].gend.$;\n                    let conj = {\n                        declension: declension,\n                        inflection: gender\n                    }\n\n                    returnArr[i] = (conj);\n                } else {\n                    let gender = inflectArr[i].gend.$;\n                    let latCase = inflectArr[i].case.$;\n                    let number = inflectArr[i].num.$;\n                    let declension = inflectArr[i].decl.$;\n                    let conj = {\n                        declension: declension,\n                        inflection: `${gender} ${latCase} ${number}`\n                    }\n                    returnArr[i] = (conj);\n                }\n            }   \n            return returnArr;\n        } else {\n            if(inflectArr.gend.$ === 'adverbial') {\n                let declension = inflectArr.decl.$;\n                let gender = inflectArr.gend.$;\n                return [{\n                    declension: declension,\n                    inflection: gender\n                }];\n            } else {\n                let gender = inflectArr.gend.$;\n                let latCase = inflectArr.case.$;\n                let number = inflectArr.num.$;\n                let declension = inflectArr.decl.$;\n                returnArr = [`${declension} declension`, `${gender} ${latCase} ${number}`];\n                return [{\n                    declension: declension,\n                    inflection: `${gender} ${latCase} ${number}`\n                }];\n            }\n        } \n    } else if(type === 'pronoun') {\n        if(Array.isArray(inflectArr)){\n            for(let i = 0; i < inflectArr.length; i++){\n                let gender = inflectArr[i].gend.$;\n                let latCase = inflectArr[i].case.$;\n                let number = inflectArr[i].num.$;\n                let conj = {\n                    inflection: `${gender} ${latCase} ${number}`\n                }\n            \n                returnArr[i] = (conj);\n            }   \n            return returnArr;\n        } else {\n            let gender = inflectArr.gend.$;\n            let latCase = inflectArr.case.$;\n            let number = inflectArr.num.$;\n            \n            return [{\n                inflection: `${gender} ${latCase} ${number}`\n            }];\n        }\n    }\n};\n\nconst getWikiLatin = async (lemma) => { // probably should refactor this... retrieves wiktionary definition for the latin headword.\n    const latinDef = await fetch (`https://en.wiktionary.org/api/rest_v1/page/definition/${lemma}?redirect=true`);\n    const defOut = await latinDef.json();\n    const defOut_Latin = defOut.la[0];\n    \n    let defHTML = defOut_Latin.definitions[0].definition;\n\n    document.getElementById('latin').innerHTML = defHTML;\n    let titles = document.querySelectorAll('#latin a');\n    let sumDef = `${titles[0].textContent}`;\n    for(let i = 1; i < titles.length; i++){\n        sumDef = sumDef + `, ${titles[i].textContent}`;\n    }\n\n    return sumDef;\n};\n\n// Deprecated function retrieving dictionary information from perseus.tufts.edu \n// const getPerseusLatin = async (lemma) => {\n//     let dataAsJson = {};\n//     const data = await fetch(`https://www.perseus.tufts.edu/hopper/xmlchunk?doc=Perseus%3Atext%3A1999.04.0060%3Aentry%3D${lemma}`);\n//     const textData = await data.text();\n    \n\n//     if (textData.indexOf('An Error Occurred') > -1){\n//         const data1 = await fetch(`https://www.perseus.tufts.edu/hopper/xmlchunk?doc=Perseus%3Atext%3A1999.04.0060%3Aentry%3D${lemma}1`);\n//         const textData1 = await data1.text();\n//         if (textData1.indexOf('An Error Occurred') > -1){\n//             return \"Can't Find Entry\";\n//         } else {\n//             dataAsJson = JSON.parse(convert.xml2json(textData1, {compact: true, spaces: 4}));\n//             const lower = dataAsJson[\"TEI.2\"].text.body.div0.entry.sense;\n//             let defArray = [];\n//             for(let i = 0; i < lower.length; i++){\n//                 const flatter = flatten(lower[i]);\n//                 //console.log(flatter);\n//                 let regex1 = /^_text.0/;\n//                 let regex2 = /_text$/\n//                 let regex3 = /^foreign./;\n//                 let regex4 = /^usg./;\n\n//                 const asArray = Object.entries(flatter);\n//                 const allowedArr = asArray.filter(([key, value]) => (((regex1.test(key) || regex2.test(key)) && (!regex3.test(key) && !regex4.test(key)) && (value !== \", \" && value !== \"; \" && value !== \":\"))));\n//                 const allowedObj = Object.fromEntries(allowedArr);\n        \n//                 for (const [key, value] of Object.entries(allowedObj)) {\n//                     allowedObj[key] = value.replace(/^\\s/g, '');\n//                     allowedObj[key] = value.replace(/,\\s$/, ':');\n//                 }\n        \n//                 defArray.push(allowedObj);\n//             }\n        \n//             let joined = '';\n//             for(let i = 0; i < defArray.length; i++) {\n//                 let subArr = Object.entries(defArray[i]);\n//                 const endArr = subArr.map(([key, value]) => (value) )\n//                 const endStr = endArr.join(', ');\n                \n//                 joined += endStr;\n//             }\n//             return joined;\n//         }\n//     } else {\n//         dataAsJson = JSON.parse(convert.xml2json(textData, {compact: true, spaces: 4}));\n        \n//         const lower = dataAsJson[\"TEI.2\"].text.body.div0.entry.sense;\n//         //console.log(lower);\n//         let defArray = [];\n//         let joined = '';\n//         if(Array.isArray(lower)){\n//             for(let i = 0; i < lower.length; i++){\n            \n//                 const flatter = flatten(lower[i]);\n                \n//                 //console.log(flatter);\n//                 let regex1 = /^_text.0/;\n//                 let regex2 = /_text$/\n//                 let regex3 = /^foreign./;\n//                 let regex4 = /^usg./;\n    \n//                 const asArray = Object.entries(flatter);\n                \n//                 const allowedArr = asArray.filter(([key, value]) => (((regex1.test(key) || regex2.test(key)) && (!regex3.test(key) && !regex4.test(key) && value !== \", \" && value !== \":\"))));\n//                 // (    && value !== \"; \") \n                \n//                 const allowedObj = Object.fromEntries(allowedArr);\n                \n//                 for (const [key, value] of Object.entries(allowedObj)) {\n//                     allowedObj[key] = value.replace(/^\\s/g, '');\n//                     allowedObj[key] = value.replace(/,\\s$/, ':');\n//                 }\n        \n//                 defArray.push(allowedObj);\n//             }\n            \n            \n//             for(let i = 0; i < defArray.length; i++) {\n//                 let subArr = Object.entries(defArray[i]);\n//                 const endArr = subArr.map(([key, value]) => (value) )\n//                 const endStr = endArr.join(', ');\n                \n//                 joined += endStr;\n//             }\n//         } else {\n//             const flatter = flatten(lower);\n//             //console.log(flatter);\n//             let regex1 = /^_text.0/;\n//             let regex2 = /_text$/\n//             let regex3 = /^foreign./;\n//             let regex4 = /^usg./;\n\n//             const asArray = Object.entries(flatter);\n//             const allowedArr = asArray.filter(([key, value]) => (((regex1.test(key) || regex2.test(key)) && (!regex3.test(key) && !regex4.test(key) && value !== \", \" && value !== \":\"))));\n//                 // (    && value !== \"; \") \n                \n//             const allowedObj = Object.fromEntries(allowedArr);\n            \n//             for (const [key, value] of Object.entries(allowedObj)) {\n//                 allowedObj[key] = value.replace(/^\\s/g, '');\n//                 allowedObj[key] = value.replace(/,\\s$/, ':');\n//             }\n//             // console.log(allowedObj);\n//             let subArr = Object.entries(allowedObj);\n//             const endArr = subArr.map(([key, value]) => (value) )\n//             const endStr = endArr.join(', ');\n            \n//             joined = endStr;\n//         }\n        \n//         // console.log(joined);\n//         return joined;\n//         //console.log(dataAsJson);\n//         //need to do some pretty serious parsing here. This could take a while.\n        \n//     }\n\n// };\n\nconst getLocalDict = (lemma) => { // retrieves the correct dictionary entry from the local Latin lexicon file\n    if (!latindict[lemma]) { \n        if (latindict[`${lemma}1`]) {\n            let combined = [];\n                let dictSense = latindict[`${lemma}1`].senses;\n                if (dictSense.length !== undefined && dictSense.length > 0) {\n                    for (let i = 0; i < dictSense.length; i++) {\n                        let newArr = combined.concat(dictSense[i]);\n                        combined = newArr;\n                    }\n                }\n            let dictString = combined.join(' ');\n            return dictString;\n        } else {\n            return \"Definition Not Found\";\n        }\n    } else {\n        let dictObj = latindict[lemma];\n        let dictSense = dictObj.senses;\n        let combined = [];\n        if (dictSense.length !== undefined && dictSense.length > 0) {\n            for (let i = 0; i < dictSense.length; i++) {\n                let newArr = combined.concat(dictSense[i]);\n                combined = newArr;\n            }\n        }\n        let dictString = combined.join(' ');\n    \n        return dictString;\n    }\n};\n\nexport default getLatinMorph","import '../App.css';\nimport ShowMoreText from 'react-show-more-text';\n\nconst Translation = ({key, provided, head, type, inflections, short, long, expanded, executeOnClick}) => {\n\n    const format = (item, i) => { // maps through the inflection array and returns a div containing each inflection \n\n            return(\n                <div className=\"infl\">\n                <h4 className=\"possibility\">Possibility {i + 1}</h4>\n                {Object.keys(item).map((val, i) => {\n                    return (\n                        <div className='inflect' key={i}>\n                        <div>{val.charAt(0).toUpperCase() + val.slice(1)}: {item[val]}</div>\n                        <br/>\n                        </div>)\n                        })}\n                </div>\n            )\n    }\n    return (\n        <div className='trans-container'>\n            <h2 className=\"title\">{provided}</h2> \n            <div className=\"type\">{type}</div><br/>\n            <div className=\"head\">{head}</div><br/>\n            <div className=\"short\">{short}</div><br/>\n            <div>{(provided !== '') ? '––––––––––––––––––––' : ''}</div>\n            <div>{inflections.map((item, i) => format(item, i))}</div>\n            <div>{(provided !== '') ? '––––––––––––––––––––' : ''}</div><br/>\n            <ShowMoreText \n                className=\"long\"\n                anchorClass='anchor-class'\n                lines={3}\n                more='Show more'\n                less='Show less'\n                onClick={executeOnClick}\n                expanded={expanded}\n            >\n                {long}\n            </ShowMoreText>\n            <br/>\n            <br/>\n        </div>    \n    )\n}\n\nexport default Translation\n","import Translation from './Translation';\n\nconst Mult = ({ input, provided, lang, expanded, setExpanded }) => { \n\n    \n\n    const executeOnClick = (isExpanded) => {\n        setExpanded(!expanded);\n    }\n    // maps through the input array and provides a Translation component from the information inside input\n    return (\n        <>\n            {input.map((el, index) => {return ( \n                <Translation \n                    provided={provided}\n                    head={`From: ${el.headword}`} \n                    type={el.type.charAt(0).toUpperCase() + el.type.slice(1)} \n                    inflections={el.inflections} \n                    short={`Wiki Definition: ${el.shortDef}`} \n                    long={(lang === 'la') ? `Lewis & Short Entry: ${el.longDef}` : `Liddell Scott Entry: ${el.longDef}`} \n                    executeOnClick={executeOnClick}\n                    expanded={expanded}\n                />\n            )})}\n        </>\n    )\n}\n\nexport default Mult\n","import React, { useState, useEffect } from 'react';\nimport getGreekMorph from './modules/javascript/greek';\nimport getLatinMorph from './modules/javascript/latin';\nimport Mult from './components/Mult';\nimport { useMediaQuery } from 'react-responsive';\nimport {Button} from '@material-ui/core';\nimport './App.css';\n\nfunction App () {\n\n  const [greek, setGreek] = useState (''); // the current value of the greek input string\n  const [latin, setLatin] = useState (''); // the current value of the latin input string\n  const [language, setLanguage] = useState(''); // the most recent language submitted by the user\n\n  const [greekArr, setGreekArr] = useState([]); // array of words from the user's input in the Greek input form\n  const [latinArr, setLatinArr] = useState([]); // array of words from the user's input in the Latin input form\n  const [displayArr, setDisplayArr] = useState([]); // the final array of words to be displayed... will be either Greek or Latin\n  const [morphList, setMorphList] = useState([]); // an array of morphs corresponding to each item in either greekArr or latinArr, depending on which the user submitted\n\n  const [visible, setVisible] = useState(false); // determines whether or not a morph is visible on the screen during mouseEnter and before mouseLeave\n  const [active, setActive] = useState(false);  // determines whetηer or not a morph is visible after a click, remaining even after mouseLeave\n  const [loaded, setLoaded] = useState(false); // changes to true once the morphList for a given input phrase by the user has been properly returned\n  const [loadingBar, setLoadingBar] = useState(true); // the status of whether or not the loading bar is visible... only appears when a phrase is loading\n  const [expanded, setExpanded] = useState(false); // whether or not the dictionary entry is in its expanded form\n\n  const [activeIndex, setActiveIndex] = useState(); // the index of the currently active morph (so in 'cogito ergo sum', if 'ergo' were active this value would be '1')\n\n  const isMobile = useMediaQuery({ query: '(max-device-width:  800px)' }) // media query to determine if the user is on a mobile device, mainly to prevent issues when clicking on the \"Show more\" tab in the dictionary entries\n\n  useEffect(() => { // whenever the user updates the greek array by inputting some string of greek text, this function retrieves the morphology information for all words in the array.\n    setLoadingBar(true);\n    async function getGreekPhrase() {\n    let arr = [];\n    if (greekArr !== []) {\n      for (let i = 0; i < greekArr.length; i++) {\n        let word = await getGreekMorph (greekArr[i]);\n        if (word === undefined) {\n          arr.push('Error: Undefined Word');\n        } else {arr.push(word)};\n      } \n    setMorphList(arr);\n    setLoaded(true);\n    } else if (greekArr.length === 1) {\n        let grekWord = await getGreekMorph(greekArr[0])\n        if (grekWord === undefined) {\n          setMorphList('Error: Undefined Word');\n        } else {\n          setMorphList(grekWord);\n        }\n        setLoaded(true);\n      }\n    }\n    getGreekPhrase();\n  }, [greekArr])\n\n  useEffect(() => { // this works exactly the same as the getGreekPhrase function in the previous hook.\n    setLoadingBar(true);\n    async function getLatinPhrase() {\n    let arr = [];\n    if (latinArr !== []) {\n      for (let i = 0; i < latinArr.length; i++) {\n        let word = await getLatinMorph (latinArr[i]);\n        if (word === undefined) {\n          arr.push('Error: Undefined Word');\n        } else {arr.push(word);}\n        \n      } \n    setMorphList(arr);\n    setLoaded(true);\n      \n    } else if (latinArr.length === 1) {\n        let latWord = await getLatinMorph(latinArr[0])\n        if (latWord === undefined) {\n          setMorphList('Error: Undefined Word');\n        } else {setMorphList(latWord);}\n        setLoaded(true);\n      }\n    }\n    getLatinPhrase();\n  }, [latinArr])\n\n  useEffect(() => { // if the morphList changes (the full list of morphology items for the user's input string), it sets the display array to be either Greek or Latin depending on what the user input.\n    setLoadingBar(false);\n    if (language === 'la') {setDisplayArr(latinArr)}\n    if (language === 'gr') {setDisplayArr(greekArr)}\n  }, [morphList])\n\n  useEffect(() => { // testing how to update the expanded property correctly\n    console.log(expanded);\n  }, [expanded])\n\n  const displayMorph = (e, index) => { // this is what sets whether or not the morphs may display on the page. Only works when certain conditions are satisfied.  \n    if (index !== activeIndex && loaded === true) {\n      setExpanded(false);\n      setActiveIndex(index);\n      setVisible(true);\n      setActive(false);\n    }\n  }\n\n  const setClicked = (e, index) => { // if any word is clicked, this sets the morph for that word to remain on the screen even after mouseLeave\n    setActiveIndex(index);\n    setVisible(true);\n    setActive(true);\n  }\n\n  const stopDisplay = (e, index) => { // controls the removal of the display on mouseLeave from one of the words of the displayed string\n    if (active !== true && loaded === true && !isMobile) {\n      setVisible(false)\n      setActiveIndex();\n    }\n  }\n\n  const handleChange = (e, lang) => { // updates 'greek' or 'latin' in state as the user types in one of the input boxes\n    if (lang === 'greek') {\n      setGreek(e.target.value);\n    }\n    if (lang === 'latin') {\n      setLatin(e.target.value);\n    }\n  }\n\n  const handleLang = (e, lang) => { // handles user submission of either greek or latin forms\n    if (lang === 'greek') {\n      setLoaded(false); \n      setVisible(false);\n      setActive(false);\n      setActiveIndex();\n      setLanguage('gr');\n      let trimmed = greek.trim();\n      let cleaned = trimmed.replace(/[.,/#!$%^&*;:{}=\\-_`~()]/g,\"\"); // cleaning of the input string, to remove any punctuation that would mess up morph retrieval\n      let cleanedArr = cleaned.split(' ');\n      for (let i = 0; i < cleanedArr.length; i++) {\n        cleanedArr[i].trim();\n      }\n      setGreekArr(cleanedArr);\n    }\n    if (lang === 'latin') {\n      setLoaded(false);\n      setVisible(false)\n      setActiveIndex();\n      setActive(false);\n      setLanguage('la');\n      let trimmed = latin.trim();\n      let cleaned = trimmed.replace(/[.,/#!$%^&*;:{}=\\-_`~()]/g, ''); // same kind of cleaning as in the greek section\n      let cleanedArr = cleaned.split(' ');\n      for (let i = 0; i < cleanedArr.length; i++) {\n        cleanedArr[i].trim()\n      }\n      setLatinArr(cleanedArr);\n      //lat(latin)\n    }\n    e.preventDefault();\n  }\n\n    return (\n      <div>\n        <div id=\"form-container\">\n          <form \n            className=\"lang-form\" \n            onSubmit={(e) => {handleLang(e, 'greek')}}>\n              <input \n                className=\"lang-input\" \n                type=\"text\" value={greek} \n                onChange={(e) => {handleChange(e, 'greek')}} \n                name=\"gr\" \n                placeholder=\"ἄνδρα μοι ἔννεπε μοῦσα\"/>\n              <Button \n                variant=\"outlined\" \n                color=\"primary\" \n                type=\"submit\" \n                classes={{label: 'sub-button'}}\n                >Submit Greek\n              </Button>\n          </form>\n          <form \n            className=\"lang-form\" \n            onSubmit={(e) => {handleLang(e, 'latin')}}>\n              <input \n                className=\"lang-input\" \n                type=\"text\" \n                value={latin} \n                onChange={(e) => {handleChange(e, 'latin')}} \n                placeholder=\"arma virumque cano\"/>\n              <Button className='button' \n                variant=\"outlined\" \n                color=\"secondary\" \n                type=\"submit\" \n                classes={{label: 'sub-button'}}\n                >Submit Latin\n              </Button>\n          </form>\n        </div>\n        <div className='phrase-container'>\n          {displayArr.map((el, index) => (\n            <div \n              className='phrase-word' \n              key={index} \n              onMouseDown={(e) => {setClicked(e, index)}} \n              onMouseEnter={(e) => {displayMorph(e, index)}} \n              onMouseLeave={(e) => {stopDisplay(e, index)}}\n              >{el}\n            </div>\n          ))}\n        </div>\n        <div className='loading' style={loadingBar ? {height: '50px'} : {height: '0'}}>{loadingBar ? 'Loading...' : ''}</div>\n          {language === 'gr' ? (visible ? \n            <div id='translation'>\n              <Mult \n                input={morphList[activeIndex]} \n                provided={greekArr[activeIndex]} \n                lang={language}\n                expanded={expanded}\n                setExpanded = {setExpanded}\n              />\n            </div> : '') : ''}\n          {language === 'la' ? (visible ? \n            <div id='translation'>\n              <Mult \n                input={morphList[activeIndex]} \n                provided={latinArr[activeIndex]} \n                lang={language}\n                expanded={expanded}\n                setExpanded = {setExpanded}\n              />\n            </div> : '') : ''}\n          <div id='greek'></div>\n          <div id='latin'></div>\n      </div>\n    );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\n"],"sourceRoot":""}