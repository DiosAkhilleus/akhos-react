{"version":3,"sources":["modules/javascript/greek.js","modules/javascript/latin.js","components/Translation.js","components/Mult.js","App.js","index.js"],"names":["convert","require","flatten","getGreek","lemma","a","lemmaArr","split","length","getGreekMorph","morph","multiMorph","i","subMorph","push","fetch","mode","greekData","json","dataOut","body","RDF","Annotation","Body","returnArr","Array","isArray","subObj","type","undefined","rest","entry","infl","pofs","$","inflections","headWord","dict","hdwd","fixedHead","replace","inflect","getGreekInflections","getWikiGreek","shortDict","getPerseusGreek","longDict","headword","dialect","shortDef","longDef","inflection","inflectArr","combinedArr","mood","tense","voice","dial","person","pers","number","num","gender","gend","grekCase","case","nCase","declension","decl","dictEntry","entryOut","other","defArr","definitions","def","definition","fixedDef","document","getElementById","innerHTML","titles","querySelectorAll","sumDef","textContent","beta","greekToBetaCode","dataAsJson","data","text","textData","indexOf","data1","textData1","JSON","parse","xml2json","compact","spaces","lower","div0","sense","defArray","flatter","regex1","regex2","regex3","regex4","allowedArr","Object","entries","filter","key","value","test","allowedObj","fromEntries","joined","subArr","endArr","map","endStr","join","getLatin","getLatinMorph","allMorph","latinData","console","log","retArr","getLatininflectArr","getWikiLatin","getPerseusLatin","check","stringify","latCase","latTense","latMood","latVoice","conj","latinDef","defOut","defOut_Latin","la","defHTML","asArray","Translation","props","className","provided","head","short","item","keys","val","charAt","toUpperCase","slice","Math","floor","random","format","long","Mult","input","lang","App","useState","greek","setGreek","latin","setLatin","ret","setRet","setLang","setProvided","lemm","setLemm","grek","grekWord","lat","latWord","id","onSubmit","e","preventDefault","onChange","event","target","name","placeholder","Button","variant","color","classes","label","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.539d1825.chunk.js","sourcesContent":["import {  greekToBetaCode  } from 'beta-code-js'; \nconst convert = require('xml-js');\nconst flatten = require('flat');\n\nconst getGreek = async (lemma) => {\n    \n    let lemmaArr = lemma.split(' ');\n    \n    if(lemmaArr.length === 1){\n        const morph = await getGreekMorph(lemmaArr[0]);\n        //parseSingleMorph(morph);\n        return morph;\n    } else {\n        let multiMorph = [];\n        for(let i = 0; i < lemmaArr.length; i++){\n            const subMorph = await getGreekMorph(lemmaArr[i]);\n            multiMorph.push(subMorph);\n        }\n        //parseMultiMorph(multiMorph);\n        //console.log( multiMorph );\n    }\n    \n};\n\nconst getGreekMorph = async (lemma) => { //returns a full array of relevant information relating to the morphology, including the headword, part of speech, inflection possibilities, Wiktionary Def, and LSJ Def\n    \n    // fetches the given greek string from the morphology service\n    const greekData = await fetch(`http://services.perseids.org/bsp/morphologyservice/analysis/word?lang=grc&engine=morpheusgrc&word=${lemma}`, {mode: 'cors'});\n    const dataOut = await greekData.json();\n    const body = dataOut.RDF.Annotation.Body;\n    //console.log(dataOut);\n    if(body === undefined){\n        //console.log('undefined');\n    }\n\n    //console.log(dataOut);\n\n    let type;\n    let returnArr = [];\n    if(Array.isArray(body)){ // if multiple possible definitions, returns morphology array for each\n        let subObj = {};\n        for(let i = 0; i < body.length; i++){\n            if(dataOut.RDF.Annotation.Body[i].rest.entry.infl[0] !== undefined){\n                type = (dataOut.RDF.Annotation.Body[i].rest.entry.infl[0].pofs.$);\n            } else {\n                type = dataOut.RDF.Annotation.Body[i].rest.entry.infl.pofs.$;\n            }\n            const inflections = dataOut.RDF.Annotation.Body[i].rest.entry.infl;\n            let headWord = dataOut.RDF.Annotation.Body[i].rest.entry.dict.hdwd.$;\n            let fixedHead = headWord.replace(/[1-9]/g, '');\n            const inflect = getGreekInflections(inflections, type);\n            const shortDict = await getWikiGreek(fixedHead);\n            const longDict = await getPerseusGreek(fixedHead);\n\n            //console.log(shortDict);\n\n            if(inflect === undefined){ // iff word is not inflected, returns array without inflections (numerals, particles, etc.)\n                subObj = {\n                            headword: fixedHead, \n                            type: type, \n                            inflections: [\n                                {\n                                    dialect: \"n/a\",\n                                    inflections: \"uninflected\"\n                                }\n                            ], \n                            shortDef: shortDict,\n                            longDef: longDict\n                        };\n            } else {\n                subObj = {\n                    headword: fixedHead, \n                    type: type, \n                    inflections: inflect,\n                    shortDef: shortDict,\n                    longDef: longDict\n                };\n            }\n            returnArr[i] = subObj;\n        }\n        \n        return returnArr; //full array of word possibilities based on each possible root headword from input word\n\n    } else { //if there is only one root headword possible\n        \n        if(dataOut.RDF.Annotation.Body.rest.entry.infl[0] !== undefined){\n            type = (dataOut.RDF.Annotation.Body.rest.entry.infl[0].pofs.$);\n        } else {\n            type = dataOut.RDF.Annotation.Body.rest.entry.infl.pofs.$;\n        }\n    \n        const inflections = dataOut.RDF.Annotation.Body.rest.entry.infl;\n        let headWord = dataOut.RDF.Annotation.Body.rest.entry.dict.hdwd.$;\n        let fixedHead = headWord.replace(/[1-9]/g, '');\n        const inflect = getGreekInflections(inflections, type);\n        const shortDict = await getWikiGreek(fixedHead);\n        const longDict = await getPerseusGreek(fixedHead);\n\n        if(inflect === undefined){ // as before, if word is not inflected, returns array without inflections (numerals, particles, etc.)\n            return [{\n                    headword: fixedHead, \n                    type: type, \n                    inflections: [\n                        {\n                            dialect: 'n/a',\n                            inflection: 'uninflected'\n                        }\n                    ], \n                    shortDef: shortDict,\n                    longDef: longDict\n                }];\n        } else {\n            return [{   \n                    headword: fixedHead,\n                    type: type,\n                    inflections: inflect,\n                    shortDef: shortDict,\n                    longDef: longDict\n                }];\n        }   \n    }\n};\n\nconst getGreekInflections = (inflectArr, type) => { // returns an array in which each element is an object of the dialect type and inflection pattern\n\n    if (type === 'verb') { //all other if statements contain similar code that will change what is returned in the object, depending on word type.\n        if(Array.isArray(inflectArr)){ // if multiple inflection possibilities, returns array of all possible inflections. \n            let combinedArr = [];\n                for(let i = 0; i < inflectArr.length; i++){\n                    if (inflectArr[i].mood.$ === 'infinitive') {\n                        let tense = inflectArr[i].tense.$;\n                        let voice = inflectArr[i].voice.$;\n                        let mood = inflectArr[i].mood.$;\n                        if(inflectArr[i].dial){\n                            let dialect = inflectArr[i].dial.$;\n                            combinedArr[i] = {\n                                dialect: dialect,\n                                inflection: `${tense} ${voice} ${mood}`\n                            };\n                        }else {\n                            combinedArr[i] = {\n                                dialect: 'Attic',\n                                inflection: `${tense} ${voice} ${mood}`\n                            }\n                        }\n                    } else {\n                        let person = inflectArr[i].pers.$;\n                        let number = inflectArr[i].num.$;\n                        let tense = inflectArr[i].tense.$;\n                        let voice = inflectArr[i].voice.$;\n                        let mood = inflectArr[i].mood.$;\n                        if(inflectArr[i].dial){\n                            let dialect = inflectArr[i].dial.$;\n                            combinedArr[i] = {\n                                dialect: dialect,\n                                inflection: `${person} person ${number} ${tense} ${voice} ${mood}`\n                            };\n                        }else {\n                            combinedArr[i] = {\n                                dialect: 'Attic',\n                                inflection: `${person} person ${number} ${tense} ${voice} ${mood}`\n                            }\n                        }\n                    }\n                }\n            return combinedArr;\n        } else {\n            if (inflectArr.mood.$ === 'infinitive') {\n                let tense = inflectArr.tense.$;\n                let voice = inflectArr.voice.$;\n                let mood = inflectArr.mood.$;\n                if(inflectArr.dial){\n                    let dialect = inflectArr.dial.$;\n                    return [{\n                        dialect: dialect,\n                        inflection: `${tense} ${voice} ${mood}`\n                    }];\n                }else {\n                    return [{\n                        dialect: 'Attic',\n                        inflection: `${tense} ${voice} ${mood}`\n                    }];\n                }\n            } else {\n                let person = inflectArr.pers.$;\n                let number = inflectArr.num.$;\n                let tense = inflectArr.tense.$;\n                let voice = inflectArr.voice.$;\n                let mood = inflectArr.mood.$;\n                if(inflectArr.dial){\n                    let dialect = inflectArr.dial.$;\n                    return [{\n                        dialect: dialect,\n                        inflection: `${person} person ${number} ${tense} ${voice} ${mood}`\n                    }];\n                }else {\n                    return [{\n                        dialect: 'Attic',\n                        inflection: `${person} person ${number} ${tense} ${voice} ${mood}`\n                    }];\n                }\n            }\n            \n        }\n    } else if (type === 'verb participle') {\n        if(Array.isArray(inflectArr)){\n            let combinedArr = [];\n                for(let i = 0; i < inflectArr.length; i++){\n                    let gender = inflectArr[i].gend.$;\n                    let grekCase = inflectArr[i].case.$;\n                    let number = inflectArr[i].num.$;\n                    let tense = inflectArr[i].tense.$;\n                    let voice = inflectArr[i].voice.$;\n                    let mood = inflectArr[i].mood.$;\n                    if(inflectArr[i].dial){\n                        let dialect = inflectArr[i].dial.$;\n                        combinedArr[i] = {\n                            dialect: dialect, \n                            inflection: `${gender} ${grekCase} ${number} ${tense} ${voice} ${mood}`\n                        };\n                    } else {\n                        combinedArr[i] = {\n                            dialect: 'Attic',\n                            inflection: `${gender} ${grekCase} ${number} ${tense} ${voice} ${mood}`\n                        };\n                    }\n                }\n            return combinedArr;\n        } else {\n            let gender = inflectArr.gend.$;\n            let grekCase = inflectArr.case.$;\n            let number = inflectArr.num.$;\n            let tense = inflectArr.tense.$;\n            let voice = inflectArr.voice.$;\n            let mood = inflectArr.mood.$;\n            if(inflectArr.dial){\n                let dialect = inflectArr.dial.$;\n                return [{\n                    dialect: dialect, \n                    inflection: `${gender} ${grekCase} ${number} ${tense} ${voice} ${mood}`\n                }];\n            } else {\n                return [{\n                    dialect: 'Attic',\n                    inflection: `${gender} ${grekCase} ${number} ${tense} ${voice} ${mood}`\n                }];\n            }\n        }\n    } else if (type === 'noun') {\n        if(Array.isArray(inflectArr)){\n            let combinedArr = [];\n                for(let i = 0; i < inflectArr.length; i++){\n                    \n                    let gender = inflectArr[i].gend.$;\n                    let nCase = inflectArr[i].case.$;\n                    let number = inflectArr[i].num.$;\n                    let declension = inflectArr[i].decl.$;\n                    if(inflectArr[i].dial){\n                        let dialect = inflectArr[i].dial.$;\n                        combinedArr[i] = {\n                            dialect: dialect, \n                            declension: declension,\n                            inflection: `${gender} ${nCase} ${number}`\n                        };\n                    } else {\n                        combinedArr[i] = {\n                            dialect: 'Attic', \n                            declension: declension,\n                            inflection: `${gender} ${nCase} ${number}`\n                        };\n                    }\n                }\n            return combinedArr;\n        }\n        let gender = inflectArr.gend.$;\n        let nCase = inflectArr.case.$;\n        let number = inflectArr.num.$;\n        let declension = inflectArr.decl.$;\n        if(inflectArr.dial){\n            let dialect = inflectArr.dial.$;\n            return [{\n                dialect: dialect, \n                declension: declension,\n                inflection: `${gender} ${nCase} ${number}`\n            }];\n        } else {\n            return [{\n                dialect: 'Attic', \n                declension: declension,\n                inflection: `${gender} ${nCase} ${number}`\n            }];\n        }\n    } else if (type === 'adjective') {\n        if(Array.isArray(inflectArr)){\n            let combinedArr = [];\n                for(let i = 0; i < inflectArr.length; i++){\n                    \n                    let gender = inflectArr[i].gend.$;\n                    let nCase = inflectArr[i].case.$;\n                    let number = inflectArr[i].num.$;\n                    let declension = inflectArr[i].decl.$;\n                    if(inflectArr[i].dial){\n                        let dialect = inflectArr[i].dial.$;\n                        combinedArr[i] = {\n                            dialect: dialect, \n                            declension: declension,\n                            inflection: `${gender} ${nCase} ${number}`\n                        };\n                    } else {\n                        combinedArr[i] = {\n                            dialect: 'Attic',\n                            declension: declension,\n                            inflection: `${gender} ${nCase} ${number}`\n                        };\n                    }\n                }\n            return combinedArr;\n        }\n        let gender = inflectArr.gend.$;\n        let nCase = inflectArr.case.$;\n        let number = inflectArr.num.$;\n        let declension = inflectArr.decl.$;\n        if(inflectArr.dial){\n            let dialect = inflectArr.dial.$;\n            return [{\n                dialect: dialect, \n                declension: declension,\n                inflection: `${gender} ${nCase} ${number}`\n            }]; \n        } else {\n            return [{\n                dialect: 'Attic',\n                declension: declension,\n                inflection: `${gender} ${nCase} ${number}`\n            }];\n        }\n    } else if (type === 'pronoun') {\n        if(Array.isArray(inflectArr)){\n            let combinedArr = [];\n                for(let i = 0; i < inflectArr.length; i++){\n                    if(inflectArr[i].pers !== undefined) {\n                        let person = inflectArr[i].pers.$;\n                        let gender = inflectArr[i].gend.$;\n                        let nCase = inflectArr[i].case.$;\n                        let number = inflectArr[i].num.$;\n                        \n                        combinedArr[i] = {\n                            inflection: `${person} person ${gender} ${nCase} ${number}`\n                        };\n                    } else {\n                        let gender = inflectArr[i].gend.$;\n                        let nCase = inflectArr[i].case.$;\n                        let number = inflectArr[i].num.$;\n\n                        combinedArr[i] = {\n                            inflection: `${gender} ${nCase} ${number}`\n                        };\n                    }\n                    \n                }\n            return combinedArr;\n        } else {\n            let person = inflectArr.pers.$;\n            let gender = inflectArr.gend.$;\n            let nCase = inflectArr.case.$;\n            let number = inflectArr.num.$;\n            return [{\n                inflection: `${person} person ${gender} ${nCase} ${number}`\n            }];\n        }\n        \n    } else if (type === 'article') {\n        if(Array.isArray(inflectArr)){\n            let combinedArr = [];\n                for(let i = 0; i < inflectArr.length; i++){\n                    \n                    let gender = inflectArr[i].gend.$;\n                    let nCase = inflectArr[i].case.$;\n                    let number = inflectArr[i].num.$;\n                    if(inflectArr[i].dial){\n                        let dialect = inflectArr[i].dial.$;\n                        combinedArr[i] = {\n                            dialect: dialect, \n                            inflection: `${gender} ${nCase} ${number}`\n                        };\n                    } else {\n                        combinedArr[i] = {\n                            dialect: 'Attic', \n                            inflection: `${gender} ${nCase} ${number}`\n                        };\n                    }\n                }\n            return combinedArr;\n        }\n        let gender = inflectArr.gend.$;\n        let nCase = inflectArr.case.$;\n        let number = inflectArr.num.$;\n        if(inflectArr.dial){\n            let dialect = inflectArr.dial.$;\n            return [{\n                dialect: dialect, \n                inflection: `${gender} ${nCase} ${number}`\n            }];\n        } else {\n            return [{\n                dialect: 'Attic', \n                inflection: `${gender} ${nCase} ${number}`\n            }];\n        }\n    } \n\n    //Fix Relative Pronouns, numerals, etc...\n};\n\nconst getWikiGreek = async (lemma) => { // fetches the wiktionary definition for the input word\n    const dictEntry = await fetch(`https://en.wiktionary.org/api/rest_v1/page/definition/${lemma}`, {mode: 'cors'});\n    const entryOut = await dictEntry.json();\n    //console.log(entryOut.other)\n    \n    if (entryOut.other === undefined){\n        return \"Not Found\";\n    } else {\n        let def;\n        let defArr = entryOut.other[0].definitions;\n        \n        if(entryOut.other[0].definitions.length === 1){\n            def = entryOut.other[0].definitions[0].definition;\n            \n        } else {\n            for(let i = 0; i < defArr.length; i++ ){\n                def = def + defArr[i].definition; \n            }\n        }\n        let fixedDef = def.replace(/undefined/g, '');\n        \n        \n        document.getElementById('greek').innerHTML = fixedDef;\n    \n        let titles = document.querySelectorAll('#greek a');\n        if (titles.length === 0){\n            return document.getElementById('greek').innerHTML;\n        }\n        \n        let sumDef;\n\n        if (titles.length < 8 && titles.length > 0) {\n            for(let i = 0; i < titles.length; i++){\n                if(i === 0){\n                    sumDef = `${titles[i].textContent}`;\n                } else {\n                    sumDef = sumDef + `, ${titles[i].textContent}`;\n                }\n            }\n        } else {\n            for(let i = 0; i < titles.length/4; i++){\n                if(i === 0){\n                    sumDef = `${titles[i].textContent}`;\n                } else {\n                    sumDef = sumDef + `, ${titles[i].textContent}`;\n                }\n            }\n        }\n        //sumDef.replace(/[^a-zA-Z\\s,]/g, '')\n            \n        return sumDef;\n    }\n};\n\nconst getPerseusGreek = async (lemma) => { // retrieves the XML from the Perseus API and formats it to a human-readable state\n    const beta = greekToBetaCode(lemma);\n    \n    let dataAsJson = {};\n    const data = await fetch(`http://www.perseus.tufts.edu/hopper/xmlchunk?doc=Perseus%3Atext%3A1999.04.0058%3Aentry%3D${beta}`);\n    const textData = await data.text();\n\n    if (textData.indexOf('An Error Occurred') > -1) {\n        const data1 = await fetch(`http://www.perseus.tufts.edu/hopper/xmlchunk?doc=Perseus%3Atext%3A1999.04.0058%3Aentry%3D${beta}1`);\n        const textData1 = await data1.text();\n        if (textData1.indexOf('An Error Occurred') > -1) {\n            return \"Can't Find Entry\";\n        } else {\n            dataAsJson = JSON.parse(convert.xml2json(textData1, {compact: true, spaces: 4}));\n            const lower = dataAsJson[\"TEI.2\"].text.body.div0.entry.sense;\n        let defArray = [];\n        for(let i = 0; i < lower.length; i++){\n            const flatter = flatten(lower[i]);\n            //console.log(flatter);\n            let regex1 = /^_text.0/;\n            let regex2 = /_text$/\n            let regex3 = /^foreign./;\n            let regex4 = /^usg./;\n\n            const asArray = Object.entries(flatter);\n            const allowedArr = asArray.filter(([key, value]) => (((regex1.test(key) || regex2.test(key)) && (!regex3.test(key) && !regex4.test(key)) && (value !== \", \" && value !== \"; \" && value !== \":\"))));\n            const allowedObj = Object.fromEntries(allowedArr);\n    \n            for (const [key, value] of Object.entries(allowedObj)) {\n                allowedObj[key] = value.replace(/^\\s/g, '');\n                allowedObj[key] = value.replace(/,\\s$/, ':');\n            }\n    \n            defArray.push(allowedObj);\n        }\n        \n        let joined = '';\n        for(let i = 0; i < defArray.length; i++) {\n            let subArr = Object.entries(defArray[i]);\n            const endArr = subArr.map(([key, value]) => (value) )\n            const endStr = endArr.join(', ');\n            \n            joined += endStr;\n        }\n        return joined;\n        } \n    } else {\n        dataAsJson = JSON.parse(convert.xml2json(textData, {compact: true, spaces: 4}));\n        \n        const lower = dataAsJson[\"TEI.2\"].text.body.div0.entry.sense;\n        \n        let defArray = [];\n        \n        for(let i = 0; i < lower.length; i++){\n            \n            const flatter = flatten(lower[i]);\n            \n            //console.log(flatter);\n            let regex1 = /^_text.0/;\n            let regex2 = /_text$/\n            let regex3 = /^foreign./;\n            let regex4 = /^usg./;\n\n            const asArray = Object.entries(flatter);\n            \n            const allowedArr = asArray.filter(([key, value]) => (((regex1.test(key) || regex2.test(key)) && (!regex3.test(key) && !regex4.test(key) && value !== \", \" && value !== \":\"))));\n            // (    && value !== \"; \") \n            \n            const allowedObj = Object.fromEntries(allowedArr);\n            \n            for (const [key, value] of Object.entries(allowedObj)) {\n                allowedObj[key] = value.replace(/^\\s/g, '');\n                allowedObj[key] = value.replace(/,\\s$/, ':');\n            }\n    \n            defArray.push(allowedObj);\n        }\n        \n        let joined = '';\n        for(let i = 0; i < defArray.length; i++) {\n            let subArr = Object.entries(defArray[i]);\n            const endArr = subArr.map(([key, value]) => (value) )\n            const endStr = endArr.join(', ');\n            \n            joined += endStr;\n        }\n        // console.log(joined);\n        return joined;\n    }\n};\n\nexport default getGreek;","const convert = require('xml-js');\nconst flatten = require('flat');\n\nconst getLatin = async (lemma) => {\n    \n    let lemmaArr = lemma.split(' ');\n    \n    if(lemmaArr.length === 1){\n        const morph = await getLatinMorph(lemmaArr[0]);\n        return morph; \n    } else {\n        let allMorph = [];\n        for(let i = 0; i < lemmaArr.length; i++){\n            const subMorph = await getLatinMorph(lemmaArr[i]);\n            allMorph.push(subMorph);\n        }\n        return allMorph;\n    }\n};\n\nconst getLatinMorph = async (lemma) => { //returns a full array of relevant information relating to the morphology, including the headword, part of speech, inflection possibilities, Wiktionary Def, and Lewis & Short entry\n    const latinData = await fetch(`http://services.perseids.org/bsp/morphologyservice/analysis/word?lang=lat&engine=morpheuslat&word=${lemma}`, {mode: 'cors'})\n    const dataOut = await latinData.json();\n    const body = dataOut.RDF.Annotation.Body;\n\n    if (body === undefined) {\n        console.log('undefined');\n    }\n    //console.log(dataOut);\n    if(Array.isArray(body)) {\n        let retArr = [];\n        for(let i = 0; i < body.length; i++){\n            const inflectArr = body[i].rest.entry.infl;\n            let headWord = body[i].rest.entry.dict.hdwd.$;\n            let fixedHead = headWord.replace(/[1-9]/g, '');\n            const type = body[i].rest.entry.dict.pofs.$;\n            const inflect = getLatininflectArr(inflectArr, type);\n            const shortDict = await getWikiLatin(fixedHead);\n            const longDict = await getPerseusLatin(fixedHead);\n            let subObj = {};\n            let check = false; \n            \n            if(inflect === undefined){ // if word is not inflected, returns array without inflectArr (numerals, particles, etc.)\n                subObj = {\n                    headword: fixedHead, \n                    type: type, \n                    inflections: [\n                        {\n                            inflections: \"uninflected\"\n                        }\n                    ], \n                    shortDef: shortDict,\n                    longDef: longDict\n                };\n            } else {\n                subObj = {\n                    headword: fixedHead, \n                    type: type, \n                    inflections: inflect,\n                    shortDef: shortDict,\n                    longDef: longDict\n                };\n            }\n            \n            //console.log(setArr);\n            \n            for(let i = 0; i < retArr.length; i++) {\n                    if(JSON.stringify(subObj) === JSON.stringify(retArr[i])){\n                        check = true;\n                    }\n            }\n            if(check === false) {\n                \n                retArr[i] = (subObj);\n            }\n        }\n        \n\n    return retArr;\n    } else {\n        const inflectArr = body.rest.entry.infl;\n        let headWord = body.rest.entry.dict.hdwd.$;\n        let fixedHead = headWord.replace(/[1-9]/g, '');\n        //console.log(fixedHead);\n        const type = body.rest.entry.dict.pofs.$;\n        const inflect = getLatininflectArr(inflectArr, type);\n        const shortDict = await getWikiLatin(fixedHead);\n        const longDict = await getPerseusLatin(fixedHead);\n        //console.log(inflect);\n        if(inflect === undefined){ // as before, if word is not inflected, returns array without inflectArr (numerals, particles, etc.)\n            //console.log(\"UND\");\n            return [{\n                    headword: fixedHead, \n                    type: type, \n                    inflections: [\n                        {\n                            inflection: 'uninflected'\n                        }\n                    ], \n                    shortDef: shortDict,\n                    longDef: longDict\n            }];\n        } else {\n            return [{   \n                headword: fixedHead,\n                type: type,\n                inflections: inflect,\n                shortDef: shortDict,\n                longDef: longDict\n            }];\n        }  \n    }\n};\n\nconst getLatininflectArr = (inflectArr, type) => {\n    //console.log(inflectArr, type); \n    let returnArr = [];\n    if(type === 'verb') {\n        if(Array.isArray(inflectArr)){\n            for(let i = 0; i < inflectArr.length; i++){\n                if(inflectArr[i].mood.$ === 'participle'){\n                    let gender = inflectArr[i].gend.$;\n                    let latCase = inflectArr[i].case.$;\n                    let number = inflectArr[i].num.$;\n                    let latTense = inflectArr[i].tense.$;\n                    let latMood = inflectArr[i].mood.$;\n                    let subObj = {\n                        inflection: `${gender} ${latCase} ${number} ${latTense} ${latMood}`\n                    }\n                    returnArr[i] = subObj\n                } else if(inflectArr[i].mood.$ === 'infinitive'){\n                    let latTense = inflectArr[i].tense.$;\n                    let latVoice = inflectArr[i].voice.$;\n                    let latMood = inflectArr[i].mood.$;\n                    let subObj = {\n                        inflection: `${latTense} ${latVoice} ${latMood}`\n                    }\n                    returnArr[i] = (subObj);\n                } else {\n                    let person = inflectArr[i].pers.$;\n                    let number = inflectArr[i].num.$;\n                    let latTense = inflectArr[i].tense.$;\n                    let latVoice = inflectArr[i].voice.$;\n                    let latMood = inflectArr[i].mood.$;\n                    let subObj = {\n                        inflection: `${person} person ${number} ${latTense} ${latVoice} ${latMood}`\n                    }\n                    returnArr[i] = (subObj);\n                }\n            }   \n            return returnArr;\n        } else {\n            if(inflectArr.mood.$ === 'infinitive') {\n                let latTense = inflectArr.tense.$;\n                let latVoice = inflectArr.voice.$;\n                let latMood = inflectArr.mood.$;\n\n                return [{\n                    inflection: `${latTense} ${latVoice} ${latMood}`\n                }];\n            } else if (inflectArr.mood.$ === 'participle') {\n                let gender = inflectArr.gend.$;\n                let latCase = inflectArr.case.$;\n                let number = inflectArr.num.$;\n                let latTense = inflectArr.tense.$;\n                let latMood = inflectArr.mood.$;\n                return [{\n                    inflection: `${gender} ${latCase} ${number} ${latTense} ${latMood}`\n                }]\n            }\n            \n            else {\n                let person = inflectArr.pers.$;\n                let number = inflectArr.num.$;\n                let latTense = inflectArr.tense.$;\n                let latVoice = inflectArr.voice.$;\n                let latMood = inflectArr.mood.$;\n\n                return [{\n                    inflection: `${person} person ${number} ${latTense} ${latVoice} ${latMood}`\n                }];\n            }\n        }\n    } else if(type === 'noun') {\n        if(Array.isArray(inflectArr)){\n            for(let i = 0; i < inflectArr.length; i++){\n                let gender = inflectArr[i].gend.$;\n                let latCase = inflectArr[i].case.$;\n                let number = inflectArr[i].num.$;\n                let declension = inflectArr[i].decl.$;\n                let conj = {\n                    declension: declension,\n                    inflection: `${gender} ${latCase} ${number}`\n                }\n            \n                returnArr[i] = (conj);\n            }   \n            return returnArr;\n        } else {\n            let gender = inflectArr.gend.$;\n            let latCase = inflectArr.case.$;\n            let number = inflectArr.num.$;\n            let declension = inflectArr.decl.$;\n            \n            return [{\n                declension: declension,\n                inflection: `${gender} ${latCase} ${number}`\n            }];\n        }\n    } else if(type === 'adjective') {\n        if(Array.isArray(inflectArr)) {\n            for(let i = 0; i < inflectArr.length; i++) {\n                if(inflectArr[i].gend.$ === 'adverbial') {\n                    let declension = inflectArr[i].decl.$;\n                    let gender = inflectArr[i].gend.$;\n                    let conj = {\n                        declension: declension,\n                        inflection: gender\n                    }\n\n                    returnArr[i] = (conj);\n                } else {\n                    let gender = inflectArr[i].gend.$;\n                    let latCase = inflectArr[i].case.$;\n                    let number = inflectArr[i].num.$;\n                    let declension = inflectArr[i].decl.$;\n                    let conj = {\n                        declension: declension,\n                        inflection: `${gender} ${latCase} ${number}`\n                    }\n                    returnArr[i] = (conj);\n                }\n            }   \n            return returnArr;\n        } else {\n            if(inflectArr.gend.$ === 'adverbial') {\n                let declension = inflectArr.decl.$;\n                let gender = inflectArr.gend.$;\n                return [{\n                    declension: declension,\n                    inflection: gender\n                }];\n            } else {\n                let gender = inflectArr.gend.$;\n                let latCase = inflectArr.case.$;\n                let number = inflectArr.num.$;\n                let declension = inflectArr.decl.$;\n                returnArr = [`${declension} declension`, `${gender} ${latCase} ${number}`];\n                return [{\n                    declension: declension,\n                    inflection: `${gender} ${latCase} ${number}`\n                }];\n            }\n        } \n    } else if(type === 'pronoun') {\n        if(Array.isArray(inflectArr)){\n            for(let i = 0; i < inflectArr.length; i++){\n                let gender = inflectArr[i].gend.$;\n                let latCase = inflectArr[i].case.$;\n                let number = inflectArr[i].num.$;\n                let conj = {\n                    inflection: `${gender} ${latCase} ${number}`\n                }\n            \n                returnArr[i] = (conj);\n            }   \n            return returnArr;\n        } else {\n            let gender = inflectArr.gend.$;\n            let latCase = inflectArr.case.$;\n            let number = inflectArr.num.$;\n            \n            return [{\n                inflection: `${gender} ${latCase} ${number}`\n            }];\n        }\n    }\n};\n\nconst getWikiLatin = async (lemma) => {\n    const latinDef = await fetch (`https://en.wiktionary.org/api/rest_v1/page/definition/${lemma}?redirect=true`);\n    const defOut = await latinDef.json();\n    const defOut_Latin = defOut.la[0];\n    \n    let defHTML = defOut_Latin.definitions[0].definition;\n\n    document.getElementById('latin').innerHTML = defHTML;\n    let titles = document.querySelectorAll('#latin a');\n    let sumDef = `${titles[0].textContent}`;\n    for(let i = 1; i < titles.length; i++){\n        sumDef = sumDef + `, ${titles[i].textContent}`;\n    }\n\n    return sumDef;\n};\n\nconst getPerseusLatin = async (lemma) => {\n    let dataAsJson = {};\n    const data = await fetch(`http://www.perseus.tufts.edu/hopper/xmlchunk?doc=Perseus%3Atext%3A1999.04.0060%3Aentry%3D${lemma}`);\n    const textData = await data.text();\n    \n\n    if (textData.indexOf('An Error Occurred') > -1){\n        const data1 = await fetch(`http://www.perseus.tufts.edu/hopper/xmlchunk?doc=Perseus%3Atext%3A1999.04.0060%3Aentry%3D${lemma}1`);\n        const textData1 = await data1.text();\n        if (textData1.indexOf('An Error Occurred') > -1){\n            return \"Can't Find Entry\";\n        } else {\n            dataAsJson = JSON.parse(convert.xml2json(textData1, {compact: true, spaces: 4}));\n            const lower = dataAsJson[\"TEI.2\"].text.body.div0.entry.sense;\n            let defArray = [];\n            for(let i = 0; i < lower.length; i++){\n                const flatter = flatten(lower[i]);\n                //console.log(flatter);\n                let regex1 = /^_text.0/;\n                let regex2 = /_text$/\n                let regex3 = /^foreign./;\n                let regex4 = /^usg./;\n\n                const asArray = Object.entries(flatter);\n                const allowedArr = asArray.filter(([key, value]) => (((regex1.test(key) || regex2.test(key)) && (!regex3.test(key) && !regex4.test(key)) && (value !== \", \" && value !== \"; \" && value !== \":\"))));\n                const allowedObj = Object.fromEntries(allowedArr);\n        \n                for (const [key, value] of Object.entries(allowedObj)) {\n                    allowedObj[key] = value.replace(/^\\s/g, '');\n                    allowedObj[key] = value.replace(/,\\s$/, ':');\n                }\n        \n                defArray.push(allowedObj);\n            }\n        \n            let joined = '';\n            for(let i = 0; i < defArray.length; i++) {\n                let subArr = Object.entries(defArray[i]);\n                const endArr = subArr.map(([key, value]) => (value) )\n                const endStr = endArr.join(', ');\n                \n                joined += endStr;\n            }\n            return joined;\n        }\n    } else {\n        dataAsJson = JSON.parse(convert.xml2json(textData, {compact: true, spaces: 4}));\n        \n        const lower = dataAsJson[\"TEI.2\"].text.body.div0.entry.sense;\n        //console.log(lower);\n        let defArray = [];\n        let joined = '';\n        if(Array.isArray(lower)){\n            for(let i = 0; i < lower.length; i++){\n            \n                const flatter = flatten(lower[i]);\n                \n                //console.log(flatter);\n                let regex1 = /^_text.0/;\n                let regex2 = /_text$/\n                let regex3 = /^foreign./;\n                let regex4 = /^usg./;\n    \n                const asArray = Object.entries(flatter);\n                \n                const allowedArr = asArray.filter(([key, value]) => (((regex1.test(key) || regex2.test(key)) && (!regex3.test(key) && !regex4.test(key) && value !== \", \" && value !== \":\"))));\n                // (    && value !== \"; \") \n                \n                const allowedObj = Object.fromEntries(allowedArr);\n                \n                for (const [key, value] of Object.entries(allowedObj)) {\n                    allowedObj[key] = value.replace(/^\\s/g, '');\n                    allowedObj[key] = value.replace(/,\\s$/, ':');\n                }\n        \n                defArray.push(allowedObj);\n            }\n            \n            \n            for(let i = 0; i < defArray.length; i++) {\n                let subArr = Object.entries(defArray[i]);\n                const endArr = subArr.map(([key, value]) => (value) )\n                const endStr = endArr.join(', ');\n                \n                joined += endStr;\n            }\n        } else {\n            const flatter = flatten(lower);\n            //console.log(flatter);\n            let regex1 = /^_text.0/;\n            let regex2 = /_text$/\n            let regex3 = /^foreign./;\n            let regex4 = /^usg./;\n\n            const asArray = Object.entries(flatter);\n            const allowedArr = asArray.filter(([key, value]) => (((regex1.test(key) || regex2.test(key)) && (!regex3.test(key) && !regex4.test(key) && value !== \", \" && value !== \":\"))));\n                // (    && value !== \"; \") \n                \n            const allowedObj = Object.fromEntries(allowedArr);\n            \n            for (const [key, value] of Object.entries(allowedObj)) {\n                allowedObj[key] = value.replace(/^\\s/g, '');\n                allowedObj[key] = value.replace(/,\\s$/, ':');\n            }\n            console.log(allowedObj);\n            let subArr = Object.entries(allowedObj);\n            const endArr = subArr.map(([key, value]) => (value) )\n            const endStr = endArr.join(', ');\n            \n            joined = endStr;\n        }\n        \n        // console.log(joined);\n        return joined;\n        //console.log(dataAsJson);\n        //need to do some pretty serious parsing here. This could take a while.\n        \n    }\n\n};\n\n\nexport default getLatin","import '../modules/css/translation.css';\n\nconst Translation = (props) => {\n\n    const format = (item, i) => { // maps through the inflection array and returns a div containing each inflection \n\n            return(\n                <div className=\"infl\">\n                <h4 className=\"possibility\">Possibility {i + 1}</h4>\n                {Object.keys(item).map((val, i) => {return (<div className='inflect' key={Math.floor(Math.random()*1000)}><div>{val.charAt(0).toUpperCase() + val.slice(1)}: {item[val]}</div><br/></div>)})}\n                </div>\n            )\n    }\n    return (\n        <div className='trans-container'>\n            <h2 className=\"title\">{props.provided}</h2> \n            <div className=\"type\">{props.type}</div><br/>\n            <div className=\"head\">{props.head}</div><br/>\n            <div className=\"short\">{props.short}</div><br/>\n            <div>{(props.provided !== '') ? '––––––––––––––––––––' : ''}</div>\n            <div>{props.inflections.map((item, i) => format(item, i))}</div>\n            <div>{(props.provided !== '') ? '––––––––––––––––––––' : ''}</div><br/>\n            <div className=\"long\">{props.long}</div>\n            <br/>\n            <br/>\n        </div>    \n    )\n}\n\nexport default Translation\n","import Translation from './Translation';\n\nconst Mult = (props) => { \n    // maps through the input array and provides a Translation component from the information inside input\n    return (\n        <>\n        {/* {console.log(props.input, props.provided, props.lang)} */}\n        {props.input.map((item) => {return ( \n            <Translation key={Math.random()}\n          provided={props.provided}\n          head={`From: ${item.headword}`} \n          type={item.type.charAt(0).toUpperCase() + item.type.slice(1)} \n          inflections={item.inflections} \n          short={`Wiki Definition: ${item.shortDef}`} \n          long={(props.lang === 'la') ? `Lewis & Short Entry: ${item.longDef}` : `Liddell Scott Entry: ${item.longDef}`} />\n         )})}\n        </>\n    )\n}\n\nexport default Mult\n","import React, { useState } from 'react';\nimport getGreek from './modules/javascript/greek';\nimport getLatin from './modules/javascript/latin';\nimport Mult from './components/Mult';\nimport {Button} from '@material-ui/core';\nimport './App.css';\n\nfunction App () {\n\n  const [greek, setGreek] = useState ('');\n  const [latin, setLatin] = useState ('');\n  const [ret, setRet] = useState(false);\n  const [lang, setLang] = useState('');\n  const [provided, setProvided] = useState('');\n  const [lemm, setLemm] = useState([]);\n\n  const grek = async (lemma) => { // retrieves a Mult component with multiple nested Translation components, depending on if the input word has multiple root headwords\n    \n    const grekWord = await getGreek(lemma);\n    setProvided(greek);\n    setLemm (grekWord);\n    setLang('gr');\n}\n  const lat = async (lemma) => { // same as above grek\n\n    const latWord = await getLatin(lemma);\n    setProvided(latin);\n    setLemm(latWord);\n    setLang('la');\n  }\n  const handleChangeGreek = (event) => { // as input is typed into greek form, it updates the state with the current value\n    \n    setGreek (event.target.value);\n  }\n\n  const handleChangeLatin = (event) => { // same as handleChangeGreek but for Latin\n    setLatin (event.target.value);\n  }\n\n  const handleGreek = (e) => { // handles the submission of the Greek input form\n    setRet(true);\n    e.preventDefault();\n    grek(greek);\n  }\n  const handleLatin = (e) => { // same as handleGreek but for Latin\n    setRet(true);\n    e.preventDefault();\n    lat(latin);\n  }\n\n    return (\n      <div>\n        <div id=\"form-container\">\n          <form className=\"lang-form\" onSubmit={handleGreek}>\n            <input className=\"lang-input\" type=\"text\" value={greek} onChange={handleChangeGreek} name=\"gr\" placeholder=\"ἄνδρα\"/>\n            &nbsp;\n            <Button variant=\"outlined\" color=\"primary\" type=\"submit\" classes={{label: 'sub-button'}}>Submit Greek</Button>\n          </form>\n          <form className=\"lang-form\" onSubmit={handleLatin}>\n                <input className=\"lang-input\" type=\"text\" value={latin} onChange={handleChangeLatin} placeholder=\"aequitas\"/>\n                &nbsp;\n              <Button variant=\"outlined\" color=\"secondary\" type=\"submit\" classes={{label: 'sub-button'}}>Submit Latin</Button>\n            </form>\n        </div>\n        <br/>\n          <div id=\"translation\">{(ret) ? (<Mult input={lemm} provided={provided} lang={lang}/>) : ''}</div>\n        <div id='greek'></div>\n        <div id='latin'></div>\n      </div>\n    );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\n"],"sourceRoot":""}